<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/07/075388a72a39.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a class="link" href="https://hexo.io/">Hexo <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>! This is your very first post. Check <a class="link" href="https://hexo.io/docs/">documentation <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> for more info. If you get any problems when using Hexo, you can find the answer in <a class="link" href="https://hexo.io/docs/troubleshooting.html">troubleshooting <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a> or you can ask me on <a class="link" href="https://github.com/hexojs/hexo/issues">GitHub <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/writing.html">Writing <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/server.html">Server <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/generating.html">Generating <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="highlight-container" data-rel="Bash"><figure class="iseeu highlight bash"><table><tbody><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></tbody></table></figure></div>

<p>More info: <a class="link" href="https://hexo.io/docs/one-command-deployment.html">Deployment <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
]]></content>
      <categories>
        <category>嘿嘿</category>
      </categories>
  </entry>
  <entry>
    <title>build my blog</title>
    <url>/2023/07/122701f1f353.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="基本配置"><a href="#基本配置" class="headerlink" title="基本配置"></a>基本配置</h3><p>教程，借用llq的博客<a class="link" href="https://xmnsatay.github.io/2023/02/26/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/">https://xmnsatay.github.io/2023/02/26/%E8%AE%B0%E5%BD%95%E7%AC%AC%E4%B8%80%E6%AC%A1%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/ <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="踩坑"><a href="#踩坑" class="headerlink" title="踩坑"></a>踩坑</h3><ul>
<li>hexo-d出错<ul>
<li>解决：llq说没下载hexo-deployer-git<ul>
<li>npm install hexo-deployer-git –save</li>
</ul>
</li>
</ul>
</li>
<li>图片只能在本地查看，还不会添加图床<ul>
<li>解决：用了聚合图床，后续可能会考虑使用阿里云oss</li>
<li>放个网址<a class="link" href="https://cursorhu.github.io/2022/02/28/%E6%90%AD%E5%BB%BA%E9%AB%98%E5%8F%AF%E7%A7%BB%E6%A4%8D%E7%9A%84Markdown%E5%86%99%E4%BD%9C%E5%92%8C%E5%8D%9A%E5%AE%A2%E7%8E%AF%E5%A2%83%EF%BC%9AObsidian+PicGo+Hexo+Github/">搭建高可移植的Markdown写作和博客环境：Obsidian+PicGo+Hexo+Github | ThinkNotes (cursorhu.github.io) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li><a class="link" href="https://zhuanlan.zhihu.com/p/104152479">阿里云OSS PicGo 配置图床教程 超详细 - 知乎 (zhihu.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
</ul>
</li>
<li>存放这个博客的仓库名字一开始跟github用户名不同<ul>
<li>解决：仓库名字改成了用户名</li>
<li>疑问：仓库名字设置为用户名一定可以保证后续博客域名的唯一性吗？域名不区分大小写，然后后面一搜发现github的用户名也不区分大小写哈哈哈🤣</li>
</ul>
</li>
<li>成功通过域名访问到博客后，显示的界面只有我的仓库名称<ul>
<li>解决：hexo clean后再重新操作，不知道为啥？</li>
</ul>
</li>
<li>vscode写markdown不丝滑，准备换成obsidian<ul>
<li>放个教程<a class="link" href="https://blog.esunr.xyz/2022/07/e9b42b453d9f.html#3-2-%E4%BD%BF%E7%94%A8-Obsidian-%E6%A8%A1%E6%9D%BF%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BA%E6%96%87%E7%AB%A0">Hexo + Obsidian + Git 完美的博客部署与编辑方案 | EsunR-Blog <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></li>
<li>存在的问题：按照上述方案优化，在ob里创建文件夹后在该文件夹下创建文件，可自动分类补全categories，但是后续想要修改分类的时候会自动变回原来的categories，即修改不了，猜想可能是因为自动分类插件，目前还未解决</li>
</ul>
</li>
<li>配置yml文件经常出错<ul>
<li>多注意缩进</li>
</ul>
</li>
</ul>
<h3 id="配置主题"><a href="#配置主题" class="headerlink" title="配置主题"></a>配置主题</h3><p>放个redefine的官方文档 <a class="link" href="https://redefine-docs.ohevan.com/">Theme Redefine Docs - Redefine Docs (ohevan.com) <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<h3 id="鼓励自己"><a href="#鼓励自己" class="headerlink" title="鼓励自己"></a>鼓励自己</h3><p>搭博客有点麻烦，希望我能好好记录下去，或者说在这里储存储存我的笔记哈哈哈哈😀</p>
<pre><code>&lt;!--more--&gt;
</code></pre>
]]></content>
      <categories>
        <category>实操记录</category>
      </categories>
      <tags>
        <tag>搭博客</tag>
        <tag>踩坑</tag>
      </tags>
  </entry>
  <entry>
    <title>12.2杂谈</title>
    <url>/2023/12/3d52ef79bb83.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>呃呃呃我写博客的就跟写日记一样三分钟热度</p>
]]></content>
      <categories>
        <category>тс╪г</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>7.13杂谈</title>
    <url>/2023/07/f38d710a42eb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>前天昨天简单地建起了博客，虽然碰到了很多奇怪的问题😢<br>而且虽然利用ob加图床可以很好地编辑了（排除了hexo-renderer-marked方案，因为我不用hexo new指令，直接在ob里创建文件）但是在编辑地时候，不能直接预览图片，抓耳挠腮.jpg，希望后续可以解决<br>昨天还添加了我的网易云歌单，话说这样岂不是可以不付费听付费地歌了（因为用的是我的id）好像有点危险</p>
]]></content>
      <categories>
        <category>тс╪г</category>
      </categories>
      <tags>
        <tag>日记</tag>
      </tags>
  </entry>
  <entry>
    <title>迁移博客，obsidian及图片路径相关问题</title>
    <url>/2025/03/3ab441bd3ff9.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><div class="highlight-container" data-rel="Plaintext"><figure class="iseeu highlight plaintext"><table><tbody><tr><td class="code"><pre><span class="line"></span><br><span class="line">发现报错：</span><br><span class="line"></span><br><span class="line">```text</span><br><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></tbody></table></figure></div>

<p>只需要安装：</p>
<div class="highlight-container" data-rel="Text"><figure class="iseeu highlight text"><table><tbody><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></tbody></table></figure></div>

<p>另外俩报错</p>
<p> ssh连接方式及Connection closed by 198.xx.xx.xx port 22错误解决<br><a class="link" href="https://blog.csdn.net/m0_60340438/article/details/141273109">https://blog.csdn.net/m0_60340438/article/details/141273109 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a><br>Nunjucks Error: 解决方案<br><a class="link" href="https://blog.csdn.net/weixin_45333934/article/details/108274320">https://blog.csdn.net/weixin_45333934/article/details/108274320 <i class="fa-regular fa-arrow-up-right-from-square fa-sm"></i></a></p>
<p>需求：</p>
<ol>
<li>图片显示<ul>
<li>比较简单的解决方案是使用相对路径</li>
<li>图片必须在source/images下才能显示，否则不管什么相对路径都不管用（是不是主题的问题？烦死啦哈哈）</li>
</ul>
</li>
<li>所有的笔记都在学习仓库里，不可能单独在博客仓库下编辑，所以需要从学习仓库里把笔记和图片都传到博客仓库<ul>
<li>解决方案：使用obsidian插件envelope，将学习仓库中的笔记上传再pull，然后再执行hexo d -g（后续要考虑自动化）</li>
<li>问题：该插件所有的文章都被传到同一个文件夹，即不能图片单独传到source/images下，就算pull后手动将图片移到images下，文章的图片路径（学习仓库里的相对路径）没法改成博客仓库的相对路径。。。</li>
</ul>
</li>
</ol>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020250306201923.png"><br><img lazyload="" src="/images/loading.svg" data-src="/Pasted%20image%2020250308170256.png"></p>
]]></content>
      <categories>
        <category>嘿嘿</category>
      </categories>
  </entry>
  <entry>
    <title></title>
    <url>/2025/03/a1a6e95e6be5.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>lalalla<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020250308210432.png"></p>
]]></content>
  </entry>
  <entry>
    <title>Lab4-3同态加密实验</title>
    <url>/2025/03/0449522b56bb.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>这一篇测试一下移动图片+批量改图片内链脚本</p>
<h1 id="Lab4-3同态加密实验"><a href="#Lab4-3同态加密实验" class="headerlink" title="Lab4-3同态加密实验"></a>Lab4-3同态加密实验</h1><ul>
<li><p>课程：大数据安全</p>
</li>
<li><p>组号：第9组</p>
</li>
<li><p>成员：王雨辰 2022211650    李孜炎 2022211651    肖壹夫 2022211655    徐同一 2022211657    张丽娜 2022211673</p>
</li>
</ul>
<p>	</p>
<p><strong>实验内容：</strong><br>同态加密模块是数据安全教学实验中的一个重要模块，具体功能包括Paillier加法同态加密算法的<strong>实现</strong>、加法同态加密算法与典型的全同态加密算法之间<strong>性能比较分析</strong>、基于安全等级的<strong>密钥长度选取方法</strong>、经典问题（平均工资问题）的<strong>编程实现</strong></p>
<h2 id="1-Paillier加法同态加密算法的实现"><a href="#1-Paillier加法同态加密算法的实现" class="headerlink" title="1. Paillier加法同态加密算法的实现"></a>1. Paillier加法同态加密算法的实现</h2><h6 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h6><ul>
<li><strong>生成密钥对</strong>：Paillier加密算法需要生成公钥和私钥。首先需要选择两个大素数p和 q，计算 n=p×q，然后计算 λ=lcm(p−1,q−1)，生成公钥 (n,g)和私钥 λ。</li>
<li><strong>加密</strong>：选择一个明文 m，然后计算加密密文 c:$$c=g^m\times r^n  \  mod\  n^2$$其中，r 是一个随机数，且 r需要满足与 n互质。</li>
<li><strong>加法同态性</strong>：Paillier加密支持加法同态性，即对于两个加密值 $c_1$和 $c_2$，可以通过以下操作计算加密后的结果：$$c_1 \times c_2 \mod n^2 = \text{Enc}(m_1 + m_2)$$这样，在加密后的数据上直接进行乘法操作，解密后即为明文相加的结果。</li>
<li><strong>解密</strong>：使用私钥 λ 解密密文：$$m = \frac{L(c^\lambda \mod n^2)}{L(g^\lambda \mod n^2)} \mod n$$其中，$L(x) = \frac{x - 1}{n}$是一个特殊的函数。</li>
</ul>
<h6 id="验证："><a href="#验证：" class="headerlink" title="验证："></a><strong>验证：</strong></h6><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> phe <span class="keyword">import</span> paillier  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_homomorphic_addition</span>():  </span><br><span class="line">    <span class="comment"># 生成 Paillier 密钥对  </span></span><br><span class="line">    public_key, private_key = paillier.generate_paillier_keypair()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 明文数  </span></span><br><span class="line">    m1 = <span class="number">100</span>  </span><br><span class="line">    m2 = <span class="number">200</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 使用公钥加密明文数  </span></span><br><span class="line">    encrypted1 = public_key.encrypt(m1)  </span><br><span class="line">    encrypted2 = public_key.encrypt(m2)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 同态加法（对加密的数进行加法运算）  </span></span><br><span class="line">    encrypted_sum = encrypted1 + encrypted2  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 使用私钥解密同态加法结果  </span></span><br><span class="line">    decrypted_sum = private_key.decrypt(encrypted_sum)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Decrypted sum: <span class="subst">{decrypted_sum}</span>"</span>)  <span class="comment"># 应该输出 300  </span></span><br><span class="line"><span class="comment"># 执行同态加法  </span></span><br><span class="line">paillier_homomorphic_addition()</span><br></pre></td></tr></tbody></table></figure></div>
<p>![[./Pasted image 20241115232100.png|Pasted image 20241115232100]]</p>
<hr>
<h2 id="2-加法同态加密算法与典型的全同态加密算法之间性能比较分析"><a href="#2-加法同态加密算法与典型的全同态加密算法之间性能比较分析" class="headerlink" title="2. 加法同态加密算法与典型的全同态加密算法之间性能比较分析"></a>2. 加法同态加密算法与典型的全同态加密算法之间性能比较分析</h2><p>进行 加法同态加密算法（如 Paillier）与 <strong>典型的全同态加密算法</strong>（如 BFV、CKKS 等）的性能比较分析，涉及多个方面的考量，包括加密/解密速度、同态运算的效率、密文大小、适用场景等。全同态加密（FHE，Fully Homomorphic Encryption）是支持加法和乘法等多种同态操作的加密方案，而加法同态加密（如 Paillier）只支持加法操作。</p>
<h4 id="2-1-加解密速度比较分析"><a href="#2-1-加解密速度比较分析" class="headerlink" title="2.1 加解密速度比较分析"></a>2.1 加解密速度比较分析</h4><ul>
<li><strong>加法同态加密（如 Paillier）：</strong><ul>
<li>Paillier 加密算法只支持加法同态运算，因此加密和解密速度相对较快，特别是在处理大批量数据时，效率较高。</li>
<li>加密操作通常是基于指数运算，解密操作相对较简单，通常涉及一个模逆运算。</li>
<li>由于只支持加法，同态加法操作通常比较快速，适合处理一些对加法比较密集的任务（如统计计算、隐私保护的加法操作等）。</li>
</ul>
</li>
<li><strong>全同态加密（如 BFV、CKKS）：</strong><ul>
<li>全同态加密支持加法、乘法、以及更多复杂的运算，因此其加密和解密的计算复杂度较高。</li>
<li>在支持多种同态运算时，解密过程往往需要多次密文解压、归约和解密，计算负担较大。</li>
<li>由于全同态加密支持多种运算，它的加密和解密时间会显著大于加法同态加密。</li>
</ul>
</li>
</ul>
<h6 id="代码（使用phe库版）"><a href="#代码（使用phe库版）" class="headerlink" title="代码（使用phe库版）"></a>代码（使用phe库版）</h6><p>compare.py</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> phe  </span><br><span class="line"><span class="keyword">import</span> tenseal <span class="keyword">as</span> ts  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 优化后的 Paillier 加法同态加解密 =======================def paillier_encryption_batch(values):  </span></span><br><span class="line">    <span class="comment"># 创建 Paillier 密钥对  </span></span><br><span class="line">    public_key, private_key = phe.generate_paillier_keypair()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 批量加密数据  </span></span><br><span class="line">    encrypted_values = [public_key.encrypt(value) <span class="keyword">for</span> value <span class="keyword">in</span> values]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 同态加法  </span></span><br><span class="line">    encrypted_sum = encrypted_values[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> enc_value <span class="keyword">in</span> encrypted_values[<span class="number">1</span>:]:  </span><br><span class="line">        encrypted_sum += enc_value  <span class="comment"># 批量加法  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">return</span> encrypted_sum, public_key, private_key  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_decryption</span>(<span class="params">encrypted_value, private_key</span>):  </span><br><span class="line">    <span class="comment"># 解密数据  </span></span><br><span class="line">    decrypted_value = private_key.decrypt(encrypted_value)  </span><br><span class="line">    <span class="keyword">return</span> decrypted_value  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 全同态加解密（TenSEAL - CKKS） =======================def full_homomorphic_encryption(value1, value2, context):  </span></span><br><span class="line">    <span class="comment"># 创建 CKKS 向量并加密  </span></span><br><span class="line">    encrypted_value1 = ts.ckks_vector(context, [value1])  </span><br><span class="line">    encrypted_value2 = ts.ckks_vector(context, [value2])  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 同态加法  </span></span><br><span class="line">    encrypted_sum = encrypted_value1 + encrypted_value2  </span><br><span class="line">    <span class="keyword">return</span> encrypted_sum  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_homomorphic_decryption</span>(<span class="params">encrypted_value, secret_key</span>):  </span><br><span class="line">    <span class="comment"># 解密数据  </span></span><br><span class="line">    decrypted_value = encrypted_value.decrypt(secret_key)  </span><br><span class="line">    <span class="keyword">return</span> decrypted_value[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 实验代码：比较加法同态和全同态加解密速度 =======================# Paillier 加法同态加解密（优化版）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_test</span>():  </span><br><span class="line">    <span class="comment"># 测试数据  </span></span><br><span class="line">    values = [<span class="number">15</span>, <span class="number">20</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时  </span></span><br><span class="line">    start_time = time.time()  </span><br><span class="line">    encrypted_sum, public_key, private_key = paillier_encryption_batch(values)  </span><br><span class="line">    decrypted_sum = paillier_decryption(encrypted_sum, private_key)  </span><br><span class="line">    end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出 Paillier 加解密结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 加解密时间: <span class="subst">{end_time - start_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 解密结果: <span class="subst">{decrypted_sum}</span>"</span>)  </span><br><span class="line">    <span class="keyword">return</span> end_time - start_time  <span class="comment"># 返回加解密时间  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># 全同态加解密（TenSEAL - CKKS）  </span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_homomorphic_test</span>():  </span><br><span class="line">    <span class="comment"># 创建 TenSEAL 上下文，初始化加密参数  </span></span><br><span class="line">    context = ts.context(ts.SCHEME_TYPE.CKKS, poly_modulus_degree=<span class="number">8192</span>, coeff_mod_bit_sizes=[<span class="number">60</span>, <span class="number">40</span>, <span class="number">60</span>])  </span><br><span class="line">    context.global_scale = <span class="number">2</span>**<span class="number">40</span>  <span class="comment"># 设置 global scale    context.generate_galois_keys()  # 生成 Galois 密钥  </span></span><br><span class="line">    secret_key = context.secret_key()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 测试数据  </span></span><br><span class="line">    value1, value2 = <span class="number">15</span>, <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时  </span></span><br><span class="line">    start_time = time.time()  </span><br><span class="line">    encrypted_sum = full_homomorphic_encryption(value1, value2, context)  </span><br><span class="line">    decrypted_sum = full_homomorphic_decryption(encrypted_sum, secret_key)  </span><br><span class="line">    end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出 TenSEAL 加解密结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态加解密时间: <span class="subst">{end_time - start_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态解密结果: <span class="subst">{decrypted_sum}</span>"</span>)  </span><br><span class="line">    <span class="keyword">return</span> end_time - start_time  <span class="comment"># 返回加解密时间  </span></span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 主程序：比较 Paillier 和 TenSEAL 的性能 =======================if __name__ == "__main__":  </span></span><br><span class="line">    <span class="comment"># 比较加法同态加解密时间（Paillier）  </span></span><br><span class="line">    paillier_time = paillier_test()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 比较全同态加解密时间（TenSEAL）  </span></span><br><span class="line">    full_homomorphic_time = full_homomorphic_test()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出对比结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"\n实验结果："</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 加法同态加解密时间: <span class="subst">{paillier_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态加解密时间 (TenSEAL): <span class="subst">{full_homomorphic_time}</span> 秒"</span>)</span><br></pre></td></tr></tbody></table></figure></div>

<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241118154833.png"></p>
<h6 id="代码（gmpy2）"><a href="#代码（gmpy2）" class="headerlink" title="代码（gmpy2）"></a>代码（gmpy2）</h6><p>compare2.py<br>这个版本使用gmpy2库自定义实现paillier，相比于上个版本使用phe库标准的paillier实现，加解密速度快了许多<br>原因：</p>
<ul>
<li><ul>
<li><strong><code>gmpy2</code> 的使用</strong>：手动实现中使用 <code>gmpy2</code> 来处理大整数运算，这个库在性能上远远优于 Python 的默认整数运算，因为它底层使用了 GMP 库（一个高性能的多精度算术库），专门用于大数运算。而 <code>phe</code> 库通常使用 Python 原生的大整数对象，运算效率较低。</li>
</ul>
</li>
<li><p><strong>随机数生成优化</strong>：使用 <code>random.SystemRandom()</code> 提供系统级的随机数生成，结合 <code>gmpy2.next_prime()</code> 来迅速找到合适的大素数，这减少了冗余计算，提升了密钥生成效率。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="meta">@staticmethod</span></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">_get_prime_over</span>(<span class="params">N</span>):</span><br><span class="line">    rand_func = random.SystemRandom()</span><br><span class="line">    r = gmpy2.mpz(rand_func.getrandbits(N))</span><br><span class="line">    r = gmpy2.bit_set(r, N - <span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">int</span>(gmpy2.next_prime(r))</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div>
</li>
<li><p><code>gmpy2.powmod()</code> 是直接在整数层面进行快速幂运算和取模操作，这在加密过程中的计算 <code>g^m % n^2</code> 和 <code>r^n % n^2</code> 非常高效。相比之下，<code>phe</code> 库的实现可能会包含额外的类型检查和更复杂的逻辑，这会增加计算时间。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, m</span>):</span><br><span class="line">    r = random.randint(<span class="number">1</span>, self.public_key.n - <span class="number">1</span>)</span><br><span class="line">    cipher_text = gmpy2.mod(</span><br><span class="line">        gmpy2.powmod(self.public_key.g, m, self.n_square) * gmpy2.powmod(r, self.public_key.n, self.n_square),</span><br><span class="line">        self.n_square)</span><br><span class="line">    cipher_text = CryptoNumber(cipher_text, self.n_square)</span><br><span class="line">    <span class="keyword">return</span> cipher_text</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div></li>
</ul>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> time  </span><br><span class="line"><span class="keyword">import</span> tenseal <span class="keyword">as</span> ts  </span><br><span class="line"><span class="keyword">import</span> random  </span><br><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple  </span><br><span class="line"><span class="keyword">import</span> gmpy2  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= Paillier 密钥生成 =======================class PaillierKeyGenerator:  </span></span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_get_prime_over</span>(<span class="params">N</span>):  </span><br><span class="line">        rand_func = random.SystemRandom()  </span><br><span class="line">        r = gmpy2.mpz(rand_func.getrandbits(N))  </span><br><span class="line">        r = gmpy2.bit_set(r, N - <span class="number">1</span>)  </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">int</span>(gmpy2.next_prime(r))  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">_generate_p_q</span>(<span class="params">key_size</span>):  </span><br><span class="line">        p = q = <span class="literal">None</span>  </span><br><span class="line">        n_len = <span class="number">0</span>  </span><br><span class="line">        <span class="keyword">while</span> n_len != key_size:  </span><br><span class="line">            p = PaillierKeyGenerator._get_prime_over(key_size // <span class="number">2</span>)  </span><br><span class="line">            q = p  </span><br><span class="line">            <span class="keyword">while</span> q == p:  </span><br><span class="line">                q = PaillierKeyGenerator._get_prime_over(key_size // <span class="number">2</span>)  </span><br><span class="line">            n = p * q  </span><br><span class="line">            n_len = n.bit_length()  </span><br><span class="line">        <span class="keyword">return</span> p, q  </span><br><span class="line">  </span><br><span class="line"><span class="meta">    @staticmethod  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">generate_keypair</span>(<span class="params">key_size</span>):  </span><br><span class="line">        p, q = PaillierKeyGenerator._generate_p_q(key_size)  </span><br><span class="line">        n = p * q  </span><br><span class="line">        lam = gmpy2.lcm(p - <span class="number">1</span>, q - <span class="number">1</span>)  </span><br><span class="line">  </span><br><span class="line">        n_square = <span class="built_in">pow</span>(n, <span class="number">2</span>)  </span><br><span class="line">        g = n + random.randint(n, n_square - <span class="number">1</span>)  </span><br><span class="line">        fn_L = <span class="keyword">lambda</span> x, n: (x - <span class="number">1</span>) // n  </span><br><span class="line">        mu = gmpy2.invert(fn_L(gmpy2.powmod(g, lam, n_square), n), n)  </span><br><span class="line">        <span class="keyword">while</span> gmpy2.gcd(g, n_square) != <span class="number">1</span>:  </span><br><span class="line">            g = n + random.randint(n, n_square - <span class="number">1</span>)  </span><br><span class="line">        PublicKey = namedtuple(<span class="string">"PublicKey"</span>, <span class="string">"n g"</span>)  </span><br><span class="line">        PrivateKey = namedtuple(<span class="string">"PrivateKey"</span>, <span class="string">"public_key lam mu"</span>)  </span><br><span class="line">        public_key = PublicKey(n=n, g=g)  </span><br><span class="line">        private_key = PrivateKey(public_key=public_key, lam=lam, mu=mu)  </span><br><span class="line">        <span class="keyword">return</span> public_key, private_key  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= Paillier 加解密 =======================class Paillier:  </span></span><br><span class="line">    CIPHER_MODE_ENCRYPT = <span class="number">0</span>  </span><br><span class="line">    CIPHER_MODE_DECRYPT = <span class="number">1</span>  </span><br><span class="line">    cipher = <span class="literal">None</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cipher_mode, cipher_key</span>):  </span><br><span class="line">        <span class="keyword">if</span> cipher_mode == Paillier.CIPHER_MODE_ENCRYPT:  </span><br><span class="line">            self.public_key = cipher_key  </span><br><span class="line">            self.private_key = <span class="literal">None</span>  </span><br><span class="line">        <span class="keyword">elif</span> cipher_mode == Paillier.CIPHER_MODE_DECRYPT:  </span><br><span class="line">            self.public_key = cipher_key.public_key  </span><br><span class="line">            self.private_key = cipher_key  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">raise</span> ValueError(<span class="string">'cipher_mode value must be either CIPHER_MODE_ENCRYPT or CIPHER_MODE_DECRYPT'</span>)  </span><br><span class="line">        self.cipher_mode = cipher_mode  </span><br><span class="line">        self.n_square = <span class="built_in">pow</span>(self.public_key.n, <span class="number">2</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">fn_L</span>(<span class="params">self, x</span>):  </span><br><span class="line">        <span class="keyword">return</span> (x - <span class="number">1</span>) // self.public_key.n  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">encrypt</span>(<span class="params">self, m</span>):  </span><br><span class="line">        r = random.randint(<span class="number">1</span>, self.public_key.n - <span class="number">1</span>)  </span><br><span class="line">        cipher_text = gmpy2.mod(  </span><br><span class="line">            gmpy2.powmod(self.public_key.g, m, self.n_square) * gmpy2.powmod(r, self.public_key.n, self.n_square),  </span><br><span class="line">            self.n_square)  </span><br><span class="line">        cipher_text = CryptoNumber(cipher_text, self.n_square)  </span><br><span class="line">        <span class="keyword">return</span> cipher_text  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">decrypt</span>(<span class="params">self, crypto_number</span>):  </span><br><span class="line">        numerator = self.fn_L(gmpy2.powmod(crypto_number.cipher_text, self.private_key.lam, self.n_square))  </span><br><span class="line">        numerator = gmpy2.mod(numerator * self.private_key.mu, self.public_key.n)  </span><br><span class="line">        <span class="keyword">return</span> numerator  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__str__</span>(<span class="params">self</span>):  </span><br><span class="line">        <span class="keyword">return</span> Paillier.cipher  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 同态运算 =======================class CryptoNumber:  </span></span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__init__</span>(<span class="params">self, cipher_text, n_square</span>):  </span><br><span class="line">        self.cipher_text = cipher_text  </span><br><span class="line">        self.n_square = n_square  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__add__</span>(<span class="params">self, other</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, CryptoNumber):  </span><br><span class="line">            sum_ciphertext = gmpy2.mod(self.cipher_text * other.cipher_text, self.n_square)  </span><br><span class="line">            <span class="keyword">return</span> CryptoNumber(sum_ciphertext, self.n_square)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            <span class="keyword">raise</span> TypeError(<span class="string">'Unsupported operand type(s) for +: "CryptoNumber" and "{}"'</span>.<span class="built_in">format</span>(<span class="built_in">type</span>(other)))  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">def</span> <span class="title function_">__mul__</span>(<span class="params">self, other</span>):  </span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">isinstance</span>(other, CryptoNumber):  </span><br><span class="line">            <span class="keyword">raise</span> NotImplementedError(<span class="string">'Multiplication between two "CryptoNumber" instances is not supported'</span>)  </span><br><span class="line">        <span class="keyword">else</span>:  </span><br><span class="line">            mul_cipher_text = gmpy2.mod(<span class="built_in">pow</span>(self.cipher_text, other), self.n_square)  </span><br><span class="line">            <span class="keyword">return</span> CryptoNumber(mul_cipher_text, self.n_square)  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 优化后的 Paillier 加法同态加解密 =======================def paillier_encryption_batch(values, public_key):  </span></span><br><span class="line">    paillier = Paillier(Paillier.CIPHER_MODE_ENCRYPT, public_key)  </span><br><span class="line">    <span class="comment"># 批量加密数据  </span></span><br><span class="line">    encrypted_values = [paillier.encrypt(value) <span class="keyword">for</span> value <span class="keyword">in</span> values]  </span><br><span class="line">    <span class="keyword">return</span> encrypted_values  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_homomorphic_addition</span>(<span class="params">encrypted_values</span>):  </span><br><span class="line">    encrypted_sum = encrypted_values[<span class="number">0</span>]  </span><br><span class="line">    <span class="keyword">for</span> enc_value <span class="keyword">in</span> encrypted_values[<span class="number">1</span>:]:  </span><br><span class="line">        encrypted_sum += enc_value  <span class="comment"># 同态加法  </span></span><br><span class="line">    <span class="keyword">return</span> encrypted_sum  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_decryption</span>(<span class="params">encrypted_value, private_key</span>):  </span><br><span class="line">    paillier = Paillier(Paillier.CIPHER_MODE_DECRYPT, private_key)  </span><br><span class="line">    <span class="comment"># 解密数据  </span></span><br><span class="line">    decrypted_value = paillier.decrypt(encrypted_value)  </span><br><span class="line">    <span class="keyword">return</span> decrypted_value  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">paillier_test</span>(<span class="params">public_key, private_key</span>):  </span><br><span class="line">    <span class="comment"># 测试数据  </span></span><br><span class="line">    values = [<span class="number">15</span>, <span class="number">20</span>]  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时开始  </span></span><br><span class="line">    start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 加密数据  </span></span><br><span class="line">    encrypted_values = paillier_encryption_batch(values, public_key)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 同态加法  </span></span><br><span class="line">    encrypted_sum = paillier_homomorphic_addition(encrypted_values)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 解密结果  </span></span><br><span class="line">    decrypted_sum = paillier_decryption(encrypted_sum, private_key)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时结束  </span></span><br><span class="line">    end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 加解密时间: <span class="subst">{end_time - start_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 解密结果: <span class="subst">{decrypted_sum}</span>"</span>)  </span><br><span class="line">    <span class="keyword">return</span> end_time - start_time  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 全同态加解密（TenSEAL - CKKS） =======================def full_homomorphic_encryption(value1, value2, context):  </span></span><br><span class="line">    <span class="comment"># 创建 CKKS 向量并加密  </span></span><br><span class="line">    encrypted_value1 = ts.ckks_vector(context, [value1])  </span><br><span class="line">    encrypted_value2 = ts.ckks_vector(context, [value2])  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 同态加法  </span></span><br><span class="line">    encrypted_sum = encrypted_value1 + encrypted_value2  </span><br><span class="line">    <span class="keyword">return</span> encrypted_sum  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_homomorphic_decryption</span>(<span class="params">encrypted_value, secret_key</span>):  </span><br><span class="line">    <span class="comment"># 解密数据  </span></span><br><span class="line">    decrypted_value = encrypted_value.decrypt(secret_key)  </span><br><span class="line">    <span class="keyword">return</span> decrypted_value[<span class="number">0</span>]  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">def</span> <span class="title function_">full_homomorphic_test</span>(<span class="params">context, secret_key</span>):  </span><br><span class="line">    <span class="comment"># 测试数据  </span></span><br><span class="line">    value1, value2 = <span class="number">15</span>, <span class="number">20</span>  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时开始  </span></span><br><span class="line">    start_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 加密和同态加法  </span></span><br><span class="line">    encrypted_sum = full_homomorphic_encryption(value1, value2, context)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 解密结果  </span></span><br><span class="line">    decrypted_sum = full_homomorphic_decryption(encrypted_sum, secret_key)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 计时结束  </span></span><br><span class="line">    end_time = time.time()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态加解密时间: <span class="subst">{end_time - start_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态解密结果: <span class="subst">{decrypted_sum}</span>"</span>)  </span><br><span class="line">    <span class="keyword">return</span> end_time - start_time  </span><br><span class="line">  </span><br><span class="line"><span class="comment"># ======================= 主程序：比较 Paillier 和 TenSEAL 的性能 =======================if __name__ == "__main__":  </span></span><br><span class="line">    <span class="comment"># ===== Paillier 密钥生成（不计入时间）=====  </span></span><br><span class="line">    public_key, private_key = PaillierKeyGenerator.generate_keypair(<span class="number">1024</span>)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 比较加法同态加解密时间（Paillier）  </span></span><br><span class="line">    paillier_time = paillier_test(public_key, private_key)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># ===== TenSEAL 上下文和密钥生成（不计入时间）=====  </span></span><br><span class="line">    context = ts.context(ts.SCHEME_TYPE.CKKS, poly_modulus_degree=<span class="number">8192</span>, coeff_mod_bit_sizes=[<span class="number">60</span>, <span class="number">40</span>, <span class="number">60</span>])  </span><br><span class="line">    context.global_scale = <span class="number">2</span>**<span class="number">40</span>  <span class="comment"># 设置 global scale    context.generate_galois_keys()  # 生成 Galois 密钥  </span></span><br><span class="line">    secret_key = context.secret_key()  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 比较全同态加解密时间（TenSEAL）  </span></span><br><span class="line">    full_homomorphic_time = full_homomorphic_test(context, secret_key)  </span><br><span class="line">  </span><br><span class="line">    <span class="comment"># 输出对比结果  </span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"\n实验结果："</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"Paillier 加法同态加解密时间: <span class="subst">{paillier_time}</span> 秒"</span>)  </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">f"全同态加解密时间 (TenSEAL): <span class="subst">{full_homomorphic_time}</span> 秒"</span>)</span><br></pre></td></tr></tbody></table></figure></div>
<p>![[./Pasted image 20241116144236.png|Pasted image 20241116144236]]</p>
<ul>
<li>分析<ul>
<li>加解密时间<ul>
<li>在不计入密钥生成时间的情况下，<strong>Paillier 加解密的时间显著小于全同态加密（TenSEAL）的加解密时间</strong>。</li>
</ul>
</li>
<li>解密结果<ul>
<li>加法同态解密结果是精确的，而全同态的解密结果与预期结果存在微小误差</li>
<li>原因：TenSEAL 使用的 <strong>CKKS</strong> 同态加密方案是一种近似计算的算法，主要用于处理浮点数和机器学习中的计算。由于CKKS的设计特点，<strong>同态运算过程中会引入少量的误差</strong>，尤其是在进行乘法和复杂运算时。这就是为什么解密结果不是精确的 <code>35</code>，而是一个非常接近 <code>35</code> 的浮点数。</li>
<li>如果需要在 TenSEAL 中得到更精确的结果，可以尝试调整加密参数，例如增大 <code>global_scale</code>，但这可能会增加计算时间和内存开销。</li>
</ul>
</li>
<li>根据应用需求选择合适的加密方案。Paillier 适用于需要精确计算的场景，CKKS 更适合处理浮点数和需要大量同态运算的机器学习任务。</li>
</ul>
</li>
</ul>
<p> <strong>增加同态运算的复杂度</strong><br>在 TenSEAL 中，增加更多的同态运算（如同态乘法、平方）可以延长加解密时间。</p>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">def</span> <span class="title function_">full_homomorphic_encryption</span>(<span class="params">value1, value2, context</span>):</span><br><span class="line">    <span class="comment"># 创建 CKKS 向量并加密</span></span><br><span class="line">    encrypted_value1 = ts.ckks_vector(context, [value1])</span><br><span class="line">    encrypted_value2 = ts.ckks_vector(context, [value2])</span><br><span class="line">    <span class="comment"># 同态加法</span></span><br><span class="line">    encrypted_sum = encrypted_value1 + encrypted_value2</span><br><span class="line">    <span class="comment"># 增加同态乘法</span></span><br><span class="line">    encrypted_product = encrypted_sum * encrypted_value1</span><br><span class="line">    <span class="comment"># 增加同态平方</span></span><br><span class="line">    encrypted_result = encrypted_product.square()</span><br><span class="line">    <span class="keyword">return</span> encrypted_result</span><br></pre></td></tr></tbody></table></figure></div>

<p>![[./Pasted image 20241117154800.png|Pasted image 20241117154800]]</p>
<hr>
<h4 id="2-2-密文大小的比较"><a href="#2-2-密文大小的比较" class="headerlink" title="2.2 密文大小的比较"></a>2.2 密文大小的比较</h4><h5 id="Paillier（加法同态加密）"><a href="#Paillier（加法同态加密）" class="headerlink" title="Paillier（加法同态加密）"></a><strong>Paillier（加法同态加密）</strong></h5><p>Paillier 加密方案是一种加法同态加密方案，支持加法操作的同态运算。其密文的大小主要由模数 nnn 和 n2n^2n2 的位长度决定。</p>
<ul>
<li><strong>密钥生成</strong>：Paillier 的密钥生成依赖于两个大素数 p 和 q，计算出模数 $n = p \times q和 n^2$，其密文的大小大约为$2 \times \text{bit length of } n$，即大约是 $2 \times \text{key size in bits}$。</li>
<li><strong>密文大小</strong>：通常，Paillier 密文的大小为 2048 位或 4096 位，具体取决于密钥大小。对于 1024 位的密钥，密文的大小大约为 2048 位。<br>  <strong>计算公式</strong>：$$<br>  \text{密文大小} \approx 2 \times (\text{key size in bits})$$<br>  如果使用 2048 位的密钥，密文的大小大约是 4096 位。</li>
</ul>
<h5 id="全同态加密（如-BFV-和-CKKS）"><a href="#全同态加密（如-BFV-和-CKKS）" class="headerlink" title="全同态加密（如 BFV 和 CKKS）"></a><strong>全同态加密（如 BFV 和 CKKS）</strong></h5><h2 id="全同态加密（FHE）允许对密文进行任意数量的同态运算（包括加法、乘法等）。典型的全同态加密方案如-BFV-和-CKKS，它们的密文大小通常更大，因为它们支持更复杂的操作，并且涉及更多的加密参数。-BFV-加密方案-多项式表示：BFV-使用多项式环进行加密，密文包含多项式的系数。每个系数的大小通常是由系数模数决定的。-密文大小：BFV-密文的大小由以下几个参数决定：-1-多项式度数：多项式度数-N-决定了密文中的多项式的长度。-2-系数模数：系数模数的位数决定了每个系数所需的位数。-对于-BFV，假设多项式度数为-N，每个系数的模数大小为B，则密文的大小大致为：-text-密文大小-approx-N-times-text-位数-text-系数模数-比如，选择-N-x3D-8192，每个系数模数为-60-位，则密文大小大约是-8192-times-60-位，即约-491-520-位。-CKKS-加密方案-多项式表示：CKKS-是一种专门针对近似同态加密设计的加密方案，支持浮点数的加密。与-BFV-类似，CKKS-使用多项式表示，但它在加密时采用了近似技术。-密文大小：与-BFV-类似，CKKS-的密文大小也由多项式度数和系数模数大小决定。-对于-CKKS，假设多项式度数为-NNN，系数模数大小为-BBB，则密文的大小大致为：-text-密文大小-approx-N-times-text-位数-text-系数模数-如果选择-N-x3D-8192，每个系数模数为-60-位，则密文大小大约是-8192-times-60-位，即约-491-520-位。"><a href="#全同态加密（FHE）允许对密文进行任意数量的同态运算（包括加法、乘法等）。典型的全同态加密方案如-BFV-和-CKKS，它们的密文大小通常更大，因为它们支持更复杂的操作，并且涉及更多的加密参数。-BFV-加密方案-多项式表示：BFV-使用多项式环进行加密，密文包含多项式的系数。每个系数的大小通常是由系数模数决定的。-密文大小：BFV-密文的大小由以下几个参数决定：-1-多项式度数：多项式度数-N-决定了密文中的多项式的长度。-2-系数模数：系数模数的位数决定了每个系数所需的位数。-对于-BFV，假设多项式度数为-N，每个系数的模数大小为B，则密文的大小大致为：-text-密文大小-approx-N-times-text-位数-text-系数模数-比如，选择-N-x3D-8192，每个系数模数为-60-位，则密文大小大约是-8192-times-60-位，即约-491-520-位。-CKKS-加密方案-多项式表示：CKKS-是一种专门针对近似同态加密设计的加密方案，支持浮点数的加密。与-BFV-类似，CKKS-使用多项式表示，但它在加密时采用了近似技术。-密文大小：与-BFV-类似，CKKS-的密文大小也由多项式度数和系数模数大小决定。-对于-CKKS，假设多项式度数为-NNN，系数模数大小为-BBB，则密文的大小大致为：-text-密文大小-approx-N-times-text-位数-text-系数模数-如果选择-N-x3D-8192，每个系数模数为-60-位，则密文大小大约是-8192-times-60-位，即约-491-520-位。" class="headerlink" title="全同态加密（FHE）允许对密文进行任意数量的同态运算（包括加法、乘法等）。典型的全同态加密方案如 BFV 和 CKKS，它们的密文大小通常更大，因为它们支持更复杂的操作，并且涉及更多的加密参数。###### BFV 加密方案- 多项式表示：BFV 使用多项式环进行加密，密文包含多项式的系数。每个系数的大小通常是由系数模数决定的。- 密文大小：BFV 密文的大小由以下几个参数决定：    1. 多项式度数：多项式度数 N 决定了密文中的多项式的长度。    2. 系数模数：系数模数的位数决定了每个系数所需的位数。    对于 BFV，假设多项式度数为 N，每个系数的模数大小为B，则密文的大小大致为：    $$\text{密文大小} \approx N \times \text{位数}(\text{系数模数})$$    比如，选择 N = 8192，每个系数模数为 60 位，则密文大小大约是 $8192 \times 60$位，即约 491,520 位。###### CKKS 加密方案- 多项式表示：CKKS 是一种专门针对近似同态加密设计的加密方案，支持浮点数的加密。与 BFV 类似，CKKS 使用多项式表示，但它在加密时采用了近似技术。- 密文大小：与 BFV 类似，CKKS 的密文大小也由多项式度数和系数模数大小决定。    对于 CKKS，假设多项式度数为 NNN，系数模数大小为 BBB，则密文的大小大致为：$$\text{密文大小} \approx N \times \text{位数}(\text{系数模数})$$    如果选择 N = 8192，每个系数模数为 60 位，则密文大小大约是 8192 \times 60 位，即约 491,520 位。
    "></a>全同态加密（FHE）允许对密文进行任意数量的同态运算（包括加法、乘法等）。典型的全同态加密方案如 BFV 和 CKKS，它们的密文大小通常更大，因为它们支持更复杂的操作，并且涉及更多的加密参数。<br>###### <strong>BFV 加密方案</strong><br>- <strong>多项式表示</strong>：BFV 使用多项式环进行加密，密文包含多项式的系数。每个系数的大小通常是由系数模数决定的。<br>- <strong>密文大小</strong>：BFV 密文的大小由以下几个参数决定：<br>    1. <strong>多项式度数</strong>：多项式度数 N 决定了密文中的多项式的长度。<br>    2. <strong>系数模数</strong>：系数模数的位数决定了每个系数所需的位数。<br>    对于 BFV，假设多项式度数为 N，每个系数的模数大小为B，则密文的大小大致为：<br>    $$\text{密文大小} \approx N \times \text{位数}(\text{系数模数})$$<br><br>    比如，选择 N = 8192，每个系数模数为 60 位，则密文大小大约是 $8192 \times 60$位，即约 491,520 位。<br>###### <strong>CKKS 加密方案</strong><br>- <strong>多项式表示</strong>：CKKS 是一种专门针对近似同态加密设计的加密方案，支持浮点数的加密。与 BFV 类似，CKKS 使用多项式表示，但它在加密时采用了近似技术。<br><br>- <strong>密文大小</strong>：与 BFV 类似，CKKS 的密文大小也由多项式度数和系数模数大小决定。<br><br>    对于 CKKS，假设多项式度数为 NNN，系数模数大小为 BBB，则密文的大小大致为：$$\text{密文大小} \approx N \times \text{位数}(\text{系数模数})$$<br>    如果选择 N = 8192，每个系数模数为 60 位，则密文大小大约是 8192 \times 60 位，即约 491,520 位。
    </h2><table>
<thead>
<tr>
<th>加密方案</th>
<th>密文大小（密钥大小 1024 位）</th>
<th>特点</th>
</tr>
</thead>
<tbody><tr>
<td><strong>Paillier</strong></td>
<td>2048 位（密钥大小 1024 位）</td>
<td>仅支持加法同态，适合简单的加法运算</td>
</tr>
<tr>
<td><strong>BFV</strong></td>
<td>491,520 位（8192 多项式度数，60 位系数模数）</td>
<td>支持加法和乘法同态，计算复杂度较高</td>
</tr>
<tr>
<td><strong>CKKS</strong></td>
<td>491,520 位（8192 多项式度数，60 位系数模数）</td>
<td>支持加法和乘法同态，适用于近似同态计算</td>
</tr>
</tbody></table>
<h5 id="结论："><a href="#结论：" class="headerlink" title="结论："></a>结论：</h5><ul>
<li><strong>Paillier</strong>：适用于加法同态，密文相对较小，通常为 2048 位或 4096 位，适合处理加法操作，但不支持乘法。</li>
<li><strong>BFV/CKKS</strong>：作为全同态加密方案，密文大小显著更大，通常在几百千位，适合执行更复杂的加法和乘法同态操作。</li>
</ul>
<h5 id="密文大小的影响："><a href="#密文大小的影响：" class="headerlink" title="密文大小的影响："></a>密文大小的影响：</h5><ul>
<li><strong>Paillier</strong>：因为仅支持加法同态，因此密文较小，适用于隐私保护需要较少计算量的场景。</li>
<li><strong>全同态加密（如 BFV、CKKS）</strong>：虽然密文更大，但它们可以执行更加复杂的同态操作（加法、乘法等），适用于需要进行复杂计算（如加密计算、隐私保护机器学习）的场景。</li>
</ul>
<hr>
<h4 id="2-3-适用场景"><a href="#2-3-适用场景" class="headerlink" title="2.3 适用场景"></a>2.3 适用场景</h4><h6 id="1-加法同态加密（Additive-Homomorphic-Encryption）"><a href="#1-加法同态加密（Additive-Homomorphic-Encryption）" class="headerlink" title="1. 加法同态加密（Additive Homomorphic Encryption）"></a>1. <strong>加法同态加密（Additive Homomorphic Encryption）</strong></h6><p><strong>适用场景：</strong></p>
<ul>
<li><strong>加密数据的求和与计数</strong>：<ul>
<li><strong>金融分析</strong>：在多个加密的交易数据（如账户余额、支付记录）上进行加法运算，得到加密的总额或总计数。例如，多个公司或个人可以将自己的财务数据加密后提交，进行合并、汇总或统计，而不会暴露具体的财务数据。</li>
<li><strong>电子投票</strong>：电子投票系统可以使用加法同态加密技术来实现加密的投票统计，确保每个投票人的隐私，同时能够对投票结果进行合并和统计。</li>
<li><strong>统计分析</strong>：进行数据汇总、加权求和等操作时，适合使用加法同态加密。例如，政府、银行等机构进行加密数据的统计分析，能够保持数据的隐私。</li>
<li><strong>医疗健康数据分析</strong>：多个医院或医疗机构可以使用加法同态加密分析不同患者的健康数据，进行加密汇总分析，而不会泄露患者的个人隐私。</li>
</ul>
</li>
<li><strong>简单的加法运算</strong>：<ul>
<li>加法同态加密适用于需要对加密数据进行简单的加法操作的场景。例如，在多个加密数据的加总或加权求和中非常高效。<br> <strong>优势：</strong></li>
</ul>
</li>
<li><strong>计算效率较高</strong>：相对于全同态加密，加法同态加密的计算复杂度较低，尤其在进行简单的加法运算时，性能较好。</li>
<li><strong>广泛应用于统计和汇总场景</strong>：适用于各种涉及合并、加总、计数等简单加法运算的任务。<br> <strong>局限性：</strong></li>
<li><strong>功能有限</strong>：仅支持加法操作，无法执行乘法、比较等其他复杂运算。因此，若任务涉及复杂的运算，无法仅通过加法同态加密完成。</li>
</ul>
<h6 id="2-全同态加密（Fully-Homomorphic-Encryption-FHE）"><a href="#2-全同态加密（Fully-Homomorphic-Encryption-FHE）" class="headerlink" title="2. 全同态加密（Fully Homomorphic Encryption, FHE）"></a>2. <strong>全同态加密（Fully Homomorphic Encryption, FHE）</strong></h6><p> <strong>适用场景：</strong></p>
<ul>
<li><strong>复杂的加法和乘法运算</strong>：<ul>
<li><strong>安全计算与联合学习</strong>：在多个参与方之间进行联合机器学习、数据分析等任务时，每个参与方的数据需要保持私密。全同态加密可以支持对加密数据进行复杂的运算（加法、乘法、矩阵运算等），从而实现数据共享与隐私保护的平衡。</li>
<li><strong>加密数据库查询</strong>：全同态加密可用于对加密数据进行复杂查询，例如加密的数据库中进行加法、乘法、聚合等操作，返回加密的查询结果。这对于加密数据库的隐私保护和合规性要求至关重要。</li>
<li><strong>安全多方计算</strong>：例如，在去中心化的金融（DeFi）系统中，多个独立的参与方可以用全同态加密协议执行计算（如资产计算、风险评估等），保证数据隐私的同时完成复杂的计算任务。</li>
<li><strong>生物信息学与基因数据分析</strong>：全同态加密可以保护基因数据的隐私，在加密的基因组数据上进行计算，如基因比对、遗传算法等，避免敏感数据泄漏。</li>
</ul>
</li>
<li><strong>隐私保护的机器学习与人工智能</strong>：<ul>
<li>全同态加密使得机器学习和AI算法能够在加密数据上直接执行，不必解密数据。例如，使用加密数据训练模型或在加密数据上做推理，保证数据隐私同时进行智能分析。</li>
</ul>
</li>
<li><strong>加密数据的复杂处理</strong>：<ul>
<li><strong>智能合约</strong>：在区块链智能合约中，全同态加密可以使得合约能够在加密状态下处理更复杂的逻辑，例如加密的数据计算、验证等任务。<br><strong>优势：</strong></li>
</ul>
</li>
<li><strong>支持复杂运算</strong>：全同态加密不仅支持加法，还支持乘法及其他更复杂的运算，非常适合涉及复杂数据处理的场景。</li>
<li><strong>强隐私保护</strong>：可以在完全不暴露数据的情况下执行复杂计算，保障数据的隐私性。<br> <strong>局限性：</strong></li>
<li><strong>计算开销较大</strong>：全同态加密的计算和加密密文的大小相对较大，因此效率较低，不适合处理非常大规模的数据或实时性要求较高的任务。</li>
<li><strong>实现复杂</strong>：全同态加密的实现较为复杂，通常需要专门的硬件或优化的计算环境来提升性能。</li>
</ul>
<hr>
<h3 id="2-4-加法同态加密-vs-全同态加密：对比总结"><a href="#2-4-加法同态加密-vs-全同态加密：对比总结" class="headerlink" title="2.4 加法同态加密 vs 全同态加密：对比总结"></a>2.4 <strong>加法同态加密 vs 全同态加密：对比总结</strong></h3><table>
<thead>
<tr>
<th>特性</th>
<th>加法同态加密</th>
<th>全同态加密</th>
</tr>
</thead>
<tbody><tr>
<td><strong>支持运算类型</strong></td>
<td>仅支持加法操作</td>
<td>支持加法、乘法等任意运算</td>
</tr>
<tr>
<td><strong>计算复杂度</strong></td>
<td>较低，运算效率较高</td>
<td>较高，运算效率低</td>
</tr>
<tr>
<td><strong>适用场景</strong></td>
<td>数据汇总、统计、加权求和、计数等简单加法运算</td>
<td>安全计算、机器学习、复杂查询、加密数据库等复杂运算</td>
</tr>
<tr>
<td><strong>隐私保护</strong></td>
<td>保证数据隐私，但只限于加法计算</td>
<td>更强的隐私保护，支持复杂的加密数据处理</td>
</tr>
<tr>
<td><strong>密文大小</strong></td>
<td>相对较小</td>
<td>相对较大</td>
</tr>
<tr>
<td><strong>计算能力</strong></td>
<td>高效且适合简单任务</td>
<td>适合复杂任务，但开销较大</td>
</tr>
<tr>
<td><strong>技术复杂度</strong></td>
<td>实现较简单</td>
<td>实现复杂，通常需要特殊优化</td>
</tr>
</tbody></table>
<h2 id="3-基于安全等级的密钥长度选取方法"><a href="#3-基于安全等级的密钥长度选取方法" class="headerlink" title="3.基于安全等级的密钥长度选取方法"></a>3.基于安全等级的密钥长度选取方法</h2><h3 id="3-1-Paillier加密的密钥长度选取"><a href="#3-1-Paillier加密的密钥长度选取" class="headerlink" title="3.1 Paillier加密的密钥长度选取"></a>3.1 <strong>Paillier加密的密钥长度选取</strong></h3><p>Paillier 加密是一种加法同态加密方案，其安全性通常基于大数分解的困难性（特别是整数分解问题）。</p>
<h4 id="Paillier加密的安全性分析"><a href="#Paillier加密的安全性分析" class="headerlink" title="Paillier加密的安全性分析"></a><strong>Paillier加密的安全性分析</strong></h4><ul>
<li>Paillier 加密的安全性主要依赖于生成的两个大素数的保密性。</li>
<li>密钥长度的选择通常基于目标的安全等级（例如 128 位、192 位或 256 位的安全性）。</li>
</ul>
<h4 id="密钥长度的选取方法"><a href="#密钥长度的选取方法" class="headerlink" title="密钥长度的选取方法"></a><strong>密钥长度的选取方法</strong></h4><p>Paillier加密的密钥长度通常是通过两个 <strong>素数</strong>（<code>p</code> 和 <code>q</code>）的位数来确定的。密钥的大小大致等于两个素数的乘积 <code>n = p * q</code> 的位数<br><strong>128位安全性：</strong><br>对于 <strong>128位安全性</strong>，选择 <strong>1024位</strong>的密钥长度是常见的做法。这意味着选择两个 <strong>512位</strong>的大素数 <code>p</code> 和 <code>q</code> 来生成密钥。这个长度适合一般的商业应用，如在线支付、数据加密等。<br><strong>192位安全性：</strong><br>如果你需要更高的安全性，可以选择 <strong>1536位</strong>的密钥长度，意味着每个素数的位数大约是 <strong>768位</strong>。这个长度适用于对安全性要求更高的场合，如金融交易、机密数据处理等。<br><strong>256位安全性：</strong><br>对于 <strong>256位安全性</strong>，可以选择 <strong>2048位</strong>的密钥长度，即每个素数的位数是 <strong>1024位</strong>。这个长度适用于高安全需求的环境，如国家安全、军事数据保护等。</p>
<h3 id="3-2-全同态加密（FHE）基于BFV、CKKS的密钥长度选取"><a href="#3-2-全同态加密（FHE）基于BFV、CKKS的密钥长度选取" class="headerlink" title="3.2 全同态加密（FHE）基于BFV、CKKS的密钥长度选取"></a>3.2 <strong>全同态加密（FHE）基于BFV、CKKS的密钥长度选取</strong></h3><p>全同态加密（FHE）方案，如 <strong>BFV</strong>（Brakerski/Fan-Vikuntanathan）和 <strong>CKKS</strong>（Cheon-Kim-Kim-Song），它们的安全性依赖于“学习与误差”（LWE）假设或其他数学难题。FHE方案的安全性通常通过密钥和参数的大小来保证。</p>
<h4 id="密钥长度选择的影响因素"><a href="#密钥长度选择的影响因素" class="headerlink" title="密钥长度选择的影响因素"></a><strong>密钥长度选择的影响因素</strong></h4><ul>
<li><strong>多项式度数（Poly Modulus Degree）</strong>：<ul>
<li>多项式度数通常以2的幂次方表示。常见的度数有 1024, 2048, 4096, 8192 等</li>
<li>这决定了密文的大小，度数越大，密文越大，计算能力要求越高。通常，选择更高的度数以提高安全性，但也会带来更高的计算成本。</li>
<li>多项式度数也与同态操作的效率相关。多项式度数越大，支持的同态操作（如加法、乘法等）就越多，但计算复杂度和存储需求也会增加。</li>
<li>决定了多项式的长度，即参与计算的系数的数量。</li>
</ul>
</li>
<li><strong>系数模数（Coeff Mod Bit Sizes）</strong>：<ul>
<li>常见的位数有 60 位、40 位、20 位等</li>
<li>这是指每个加密数的大小，位数越高，表示每个数可以存储更大的值，因此也提高了安全性。</li>
<li>系数模数影响加密过程中数值的“噪声”水平。噪声过大可能会导致解密错误，因此系数模数的选择必须平衡安全性和噪声管理。</li>
<li>决定了每个多项式系数的大小和范围，通常需要大于多项式的大小。</li>
</ul>
</li>
</ul>
<h4 id="BFV加密的密钥长度选取"><a href="#BFV加密的密钥长度选取" class="headerlink" title="BFV加密的密钥长度选取"></a><strong>BFV加密的密钥长度选取</strong></h4><p>BFV 加密方案广泛应用于加密计算和同态运算。BFV 的安全性依赖于 <strong>大整数的分解问题</strong> 和 <strong>噪声的积累</strong>。</p>
<ul>
<li><strong>加密安全性</strong>：选择 BFV 时，密钥大小和多项式的度数决定了安全性等级。</li>
<li><strong>密钥长度与安全等级</strong>：<ul>
<li><strong>128 位安全性</strong>：推荐使用 2048 位或 3072 位的公钥和密钥长度。</li>
<li><strong>192 位安全性</strong>：通常选择 4096 位或更长的密钥。</li>
<li><strong>256 位安全性</strong>：使用更长的密钥（如 8192 位及以上）。</li>
</ul>
</li>
</ul>
<h4 id="CKKS加密的密钥长度选取"><a href="#CKKS加密的密钥长度选取" class="headerlink" title="CKKS加密的密钥长度选取"></a><strong>CKKS加密的密钥长度选取</strong></h4><p>CKKS 是针对<strong>近似同态加密</strong>（Approximate Homomorphic Encryption, AHE）的一种方案，特别适用于连续数据如浮点数加密。它基于 <strong>LWE</strong>（学习带误差）假设。</p>
<ul>
<li><strong>加密安全性</strong>：CKKS 加密的安全性同样依赖于多项式的度数和系数模数。CKKS 的密钥选择通常与 <strong>poly_modulus_degree</strong>（多项式度数）和 <strong>coeff_mod_bit_sizes</strong>（系数模数）相关。</li>
<li><strong>常见的参数选择</strong>：<ul>
<li><strong>128 位安全性</strong>：常见的选择是 <strong>poly_modulus_degree = 8192</strong> 和 **coeff_mod_bit_sizes = [60, 40, 60]**。</li>
<li><strong>192 位安全性</strong>：通常选择更大的多项式度数，如 <strong>poly_modulus_degree = 16384</strong> 和 **coeff_mod_bit_sizes = [60, 40, 60]**。</li>
<li><strong>256 位安全性</strong>：可能选择 <strong>poly_modulus_degree = 32768</strong> 和 **coeff_mod_bit_sizes = [60, 40, 60]**。</li>
</ul>
</li>
</ul>
<p>下面是一个基于安全等级选择密钥长度的推荐方法：</p>
<table>
<thead>
<tr>
<th>安全等级</th>
<th>多项式度数（poly_modulus_degree）</th>
<th>系数模数（coeff_mod_bit_sizes）</th>
</tr>
</thead>
<tbody><tr>
<td><strong>128位安全性</strong></td>
<td>8192</td>
<td>[60, 40, 60]</td>
</tr>
<tr>
<td><strong>192位安全性</strong></td>
<td>16384</td>
<td>[60, 50, 60]</td>
</tr>
<tr>
<td><strong>256位安全性</strong></td>
<td>16384</td>
<td>[80, 60, 80]</td>
</tr>
</tbody></table>
<h2 id="4-经典问题的编程实现"><a href="#4-经典问题的编程实现" class="headerlink" title="4. 经典问题的编程实现"></a>4. 经典问题的编程实现</h2><div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> tenseal <span class="keyword">as</span> ts</span><br><span class="line"></span><br><span class="line"><span class="comment"># 1. 初始化 TenSEAL 上下文</span></span><br><span class="line">context = ts.context(ts.SCHEME_TYPE.CKKS, poly_modulus_degree=<span class="number">8192</span>, coeff_mod_bit_sizes=[<span class="number">60</span>, <span class="number">40</span>, <span class="number">60</span>])</span><br><span class="line">context.generate_galois_keys()</span><br><span class="line"></span><br><span class="line"><span class="comment"># 2. 设置 global_scale</span></span><br><span class="line">context.global_scale = <span class="number">2</span>**<span class="number">60</span>  <span class="comment"># 设置较大的 global scale，通常为 2 的较大次幂</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 3. 模拟一些工资数据</span></span><br><span class="line"><span class="comment"># 假设有5个员工的工资</span></span><br><span class="line">salaries = [<span class="number">5000</span>, <span class="number">5500</span>, <span class="number">6000</span>, <span class="number">6500</span>, <span class="number">7000</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 4. 对工资数据进行加密</span></span><br><span class="line"><span class="comment"># 使用 TenSEAL 的 ckks_vector 进行加密</span></span><br><span class="line">encrypted_salaries = [ts.ckks_vector(context, [salary]) <span class="keyword">for</span> salary <span class="keyword">in</span> salaries]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 5. 计算加密工资的总和（同态加法）</span></span><br><span class="line">encrypted_sum = encrypted_salaries[<span class="number">0</span>]</span><br><span class="line"><span class="keyword">for</span> encrypted_salary <span class="keyword">in</span> encrypted_salaries[<span class="number">1</span>:]:</span><br><span class="line">    encrypted_sum = encrypted_sum + encrypted_salary</span><br><span class="line"></span><br><span class="line"><span class="comment"># 6. 计算总和的平均工资（解密得到结果）</span></span><br><span class="line"><span class="comment"># 计算总和之后除以工资数量</span></span><br><span class="line">decrypted_sum = encrypted_sum.decrypt()</span><br><span class="line">decrypted_average = decrypted_sum[<span class="number">0</span>] / <span class="built_in">len</span>(salaries)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 7. 输出结果</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"Encrypted total sum of salaries: <span class="subst">{decrypted_sum[<span class="number">0</span>]}</span>"</span>)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"Encrypted average salary: <span class="subst">{decrypted_average}</span>"</span>)</span><br><span class="line"></span><br></pre></td></tr></tbody></table></figure></div>

<p>![[./Pasted image 20241117212240.png|Pasted image 20241117212240]]</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>笔记迁移到博客的图片问题最终解决方案</title>
    <url>/2025/03/dfeeaecfbe86.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><p>哈哈哈<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020250308200727.png"><br>分两种情况：</p>
<ol>
<li>在学习仓库里编辑的文章，通过ob的envelope插件传到github，然后pull后执行脚本，脚本实现移动图片加修改.md中图片内链<ul>
<li>在学习仓库里还是<code>![[]]</code>格式,且选择内部链接类型为“尽可能简短模式”，<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020250308210735.png">这个要关掉</li>
</ul>
</li>
</ol>
<div class="highlight-container" data-rel="Python"><figure class="iseeu highlight python"><table><tbody><tr><td class="code"><pre><span class="line">	<span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> shutil</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> urllib.parse</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">move_images_and_update_links</span>(<span class="params">posts_dir, images_dir</span>):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 遍历_posts文件夹中的所有.md文件</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> root, dirs, files <span class="keyword">in</span> os.walk(posts_dir):</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> file <span class="keyword">in</span> files:</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> file.endswith(<span class="string">'.md'</span>):</span><br><span class="line"></span><br><span class="line">md_file_path = os.path.join(root, file)</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"正在处理文件: <span class="subst">{md_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件权限，确保它可写</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.access(md_file_path, os.W_OK):</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"没有写权限: <span class="subst">{md_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打开.md文件并读取内容</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(md_file_path, <span class="string">'r'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">content = f.read()</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查找.md文件中所有的图片链接，处理 ![[...|...]] 格式</span></span><br><span class="line"></span><br><span class="line">new_content = content</span><br><span class="line"></span><br><span class="line">image_links = re.findall(<span class="string">r'!\[\[(.*?)\|.*?\]\]'</span>, content)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> image_links:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"未找到图片链接: <span class="subst">{md_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> image_link <span class="keyword">in</span> image_links:</span><br><span class="line"></span><br><span class="line"><span class="comment"># 规范化路径，去掉 './' 部分</span></span><br><span class="line"></span><br><span class="line">image_link = os.path.normpath(image_link) <span class="comment"># 去掉 './' 等无效部分</span></span><br><span class="line"></span><br><span class="line">image_name = os.path.basename(image_link)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 计算图片的源路径</span></span><br><span class="line"></span><br><span class="line">source_image_path = os.path.join(root, image_name)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果图片链接是相对路径，尝试拼接完整路径</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">not</span> os.path.exists(source_image_path):</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果图片在子目录中，尝试调整路径</span></span><br><span class="line"></span><br><span class="line">source_image_path = os.path.join(posts_dir, image_link)</span><br><span class="line"></span><br><span class="line">destination_image_path = os.path.join(images_dir, image_name)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"检查图片路径: <span class="subst">{source_image_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查图片是否存在</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> os.path.exists(source_image_path):</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"正在移动图片: <span class="subst">{image_name}</span>"</span>)</span><br><span class="line"></span><br><span class="line">shutil.move(source_image_path, destination_image_path)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 在.md文件中将空格替换为 %20</span></span><br><span class="line"></span><br><span class="line">new_link = <span class="string">f'![](../images/<span class="subst">{urllib.parse.quote(image_name)}</span>)'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 只替换当前处理的图片链接</span></span><br><span class="line"></span><br><span class="line">new_content = re.sub(<span class="string">r'!\[\['</span> + re.escape(image_link) + <span class="string">r'\|.*?\]\]'</span>, new_link, new_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"图片不存在: <span class="subst">{source_image_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 检查文件内容是否实际变化</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> new_content != content:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件内容已更改，保存修改: <span class="subst">{md_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(md_file_path, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> f:</span><br><span class="line"></span><br><span class="line">f.write(new_content)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">print</span>(<span class="string">f"文件内容未变化: <span class="subst">{md_file_path}</span>"</span>)</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置_posts和images文件夹路径</span></span><br><span class="line"></span><br><span class="line">posts_dir = <span class="string">'./myblog/source/_posts'</span> <span class="comment"># 请替换为你实际的路径</span></span><br><span class="line"></span><br><span class="line">images_dir = <span class="string">'./myblog/source/images'</span> <span class="comment"># 请替换为你实际的路径</span></span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">move_images_and_update_links(posts_dir, images_dir)</span><br></pre></td></tr></tbody></table></figure></div>
<ol>
<li>在博客仓库里编辑的文章，进行以下设置<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020250308201636.png"></li>
</ol>
]]></content>
      <categories>
        <category>嘿嘿</category>
      </categories>
  </entry>
  <entry>
    <title>软件安全笔记</title>
    <url>/2025/03/9dcfeb082e77.html</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="/assets/css/APlayer.min.css"><script src="/assets/js/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="/assets/js/Meting.min.js"></script><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><ul>
<li><p>网络空间安全主要围绕网络空间中所存在的安全问题开展研究</p>
<ul>
<li>电磁设备</li>
<li>电子信息系统</li>
<li>网络</li>
<li>运行数据</li>
<li>系统应用</li>
</ul>
</li>
<li><p>软件安全范围：操作系统、数据库、应用软件等</p>
</li>
<li><p>软件安全关注计算机程序或程序中所包含信息的完整性、机密性和可用性等</p>
</li>
<li><p>软件安全缺陷</p>
<ul>
<li>软件<strong>漏洞</strong>是基本形态，<strong>恶意代码</strong>则是延伸的形态</li>
</ul>
</li>
<li><p>软件安全风险</p>
<ul>
<li>输入验证与表示<ul>
<li>安全问题往往都是由于对输入的信息过度信任造成的</li>
<li>主要问题包括<ul>
<li><p>缓冲区溢出</p>
<ul>
<li>格式化字符串（Format String），允许攻击者控制一个函数的格式化字符串，可能会引起缓冲区溢出；</li>
<li>非法指针值</li>
<li>整数溢出</li>
<li>字符串结束错误，依赖于字符串终止符有可能造成缓冲区溢出；</li>
</ul>
</li>
<li><h2 id="命令注入-目录游历（Path-Traversal）允许用户通过输入来控制文件系统操作使用的路径，会使攻击者有机会访问或修改被保护的系统资源；-资源注入：允许用户输入控制资源ID可能会使攻击者访问或修改系统保护的资源；-配置操控，允许外部控制系统设置有可能会导致服务崩溃或应用程序进行非法操作-SQL注入，允许用户输入来构造一个动态的SQL请求，将有可能让攻击者控制SQL语句的意思，执行任意的SQL指令"><a href="#命令注入-目录游历（Path-Traversal）允许用户通过输入来控制文件系统操作使用的路径，会使攻击者有机会访问或修改被保护的系统资源；-资源注入：允许用户输入控制资源ID可能会使攻击者访问或修改系统保护的资源；-配置操控，允许外部控制系统设置有可能会导致服务崩溃或应用程序进行非法操作-SQL注入，允许用户输入来构造一个动态的SQL请求，将有可能让攻击者控制SQL语句的意思，执行任意的SQL指令" class="headerlink" title="命令注入  - 目录游历（Path Traversal）允许用户通过输入来控制文件系统操作使用的路径，会使攻击者有机会访问或修改被保护的系统资源；  - 资源注入：允许用户输入控制资源ID可能会使攻击者访问或修改系统保护的资源；  - 配置操控，允许外部控制系统设置有可能会导致服务崩溃或应用程序进行非法操作  - SQL注入，允许用户输入来构造一个动态的SQL请求，将有可能让攻击者控制SQL语句的意思，执行任意的SQL指令"></a>命令注入<br>  - 目录游历（Path Traversal）允许用户通过输入来控制文件系统操作使用的路径，会使攻击者有机会访问或修改被保护的系统资源；<br>  - 资源注入：允许用户输入控制资源ID可能会使攻击者访问或修改系统保护的资源；<br>  - 配置操控，允许外部控制系统设置有可能会导致服务崩溃或应用程序进行非法操作<br>  - SQL注入，允许用户输入来构造一个动态的SQL请求，将有可能让攻击者控制SQL语句的意思，执行任意的SQL指令</h2></li>
<li><p>跨站脚本</p>
<ul>
<li>HTTP应答截断（HTTP Response Splitting）在在HTTP响应头中包含未经验证的数据将可能导致缓存中毒、跨站脚本、跨用户攻击或者页面劫持攻击</li>
</ul>
</li>
<li><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020240924215124.png"></p>
</li>
</ul>
</li>
</ul>
</li>
<li>API误用<ul>
<li>API是调用者与被调用者之间的一个约定，大多数的API误用是由于调用者没有理解约定的目的所造成的。</li>
</ul>
</li>
<li>安全特征</li>
<li>时间与状态</li>
<li>错误处理</li>
<li>代码质量</li>
<li>封装</li>
<li>环境</li>
</ul>
</li>
<li><p>软件漏洞的危害</p>
<ul>
<li>无法正常使用</li>
<li>引发恶性事件</li>
<li>关键数据丢失</li>
<li>秘密信息泄漏</li>
<li>被安装木马病毒</li>
</ul>
</li>
<li><p>软件漏洞出现的原因</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241112223417.png"></li>
</ul>
</li>
</ul>
<p>修改全局偏移表<br>Ω</p>
<p>.dotors区<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241024102451.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241024102726.png"><br>对于攻击者而言，覆写.dtors区的好处在于：</p>
<p>• 该区总是存在并且会映射到内存中</p>
<p>然而：</p>
<p>• .dtors仅存在于用GCC编译和链接的程序中</p>
<h5 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h5><p>此方法在window中也可使用</p>
<p>没虚函数就没VRTR<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241024103442.png"></p>
<p>可以有两种方法：</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241024104336.png"></li>
</ul>
<h5 id="4-atexit-on-exit"><a href="#4-atexit-on-exit" class="headerlink" title="4. atexit() on_exit()"></a>4. atexit() on_exit()</h5><h5 id="5-longjmp"><a href="#5-longjmp" class="headerlink" title="5. longjmp()"></a>5. longjmp()</h5><h3 id="缓冲区溢出基础"><a href="#缓冲区溢出基础" class="headerlink" title="缓冲区溢出基础"></a>缓冲区溢出基础</h3><h4 id="2-1-缓冲区溢出原理"><a href="#2-1-缓冲区溢出原理" class="headerlink" title="2.1 缓冲区溢出原理"></a>2.1 缓冲区溢出原理</h4><h4 id="2-2-进程内存空间分区"><a href="#2-2-进程内存空间分区" class="headerlink" title="2.2 进程内存空间分区"></a>2.2 进程内存空间分区</h4><h5 id="PE文件与虚拟内存之间的映射"><a href="#PE文件与虚拟内存之间的映射" class="headerlink" title="PE文件与虚拟内存之间的映射"></a>PE文件与虚拟内存之间的映射</h5><ul>
<li>文件偏移地址(File Offset)<ul>
<li>数据在PE文件中的地址</li>
<li>文件在磁盘上存放时相对于文件开头的偏移</li>
<li>文件偏移地址=RVA-节偏移</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241114101925.png"></li>
</ul>
</li>
<li>装载基址Image Base<ul>
<li>PE装入内存时的基地址</li>
<li>默认下XE文件在内存中的基地址是0x00400000</li>
<li>DLL文件是0x10000000。</li>
<li>这些位置可以通过修改编译选项更改。</li>
</ul>
</li>
<li>虚拟内存地址Virtual Address,VA<ul>
<li>PE文件中的指令被装入内存后的地址</li>
</ul>
</li>
<li>相对虚拟地址(Relative Virtual Address,RVA<ul>
<li>内存地址相对于映射基址的偏移量</li>
<li>VA=Image Base +RVA</li>
</ul>
</li>
<li>文件偏移地址在计算时要考虑存放方式的不同<ul>
<li>按照磁盘数据标准存放时：PE数据节的大小永远是0x200的整数倍<ul>
<li>以0x200字节为基本单位进行组织。当一个数据节不足0x200字节时，不足的地方将被0x00填充；</li>
</ul>
</li>
<li>装入内存时：将按照内存数据标准存放，并以0X1000字节为基本单位进行组织</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241114100625.png"></li>
<li>这种由存储单位引起的节基址差叫做节偏移</li>
</ul>
</li>
</ul>
<h5 id="进程空间功能分区"><a href="#进程空间功能分区" class="headerlink" title="进程空间功能分区"></a>进程空间功能分区</h5><ul>
<li>代码区<ul>
<li>存储着被装入执行的二进制机器代码</li>
</ul>
</li>
<li>数据区<ul>
<li>存储全局变量等</li>
</ul>
</li>
<li>堆区<ul>
<li>在堆区动态地请求一定大小的内存，并在用完之后归还给堆区</li>
<li>动态分配和回收是堆区的特点</li>
</ul>
</li>
<li>栈区<ul>
<li>动态地存储函数之间的调用关系</li>
<li>保证被调用函数在返回时恢复到父函数中继续执行</li>
</ul>
</li>
</ul>
<h4 id="2-3-系统栈的工作原理—内存的不同用途"><a href="#2-3-系统栈的工作原理—内存的不同用途" class="headerlink" title="2.3 系统栈的工作原理—内存的不同用途"></a>2.3 系统栈的工作原理—内存的不同用途</h4><p>程序中所使用的缓冲区可以是堆区、栈区和存放静态变量的数据区。缓冲区溢出的利用方法和缓冲区到底属于上面哪个内存区域密不可分，本课主要介绍在系统栈发生溢出的情形。</p>
<ul>
<li>内存的栈区实际上指的就是系统栈<ul>
<li>对于类似 C语言这样的高级语言，系统栈的PUSH/POP等堆栈平衡细节是透明的</li>
<li>用汇编语言才需要直接和栈打交道</li>
</ul>
</li>
<li>栈存储的内容<ul>
<li>调用函数的返回地址</li>
<li>函数参数</li>
<li>局部（临时）变量</li>
</ul>
</li>
<li>栈被修改的情况<ul>
<li>函数调用期间</li>
<li>函数初始化期间</li>
<li>从子例程返回时</li>
</ul>
</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241114110136.png">从内存高地址向低地址</li>
</ul>
<h4 id="2-4-函数栈帧、函数调用原理"><a href="#2-4-函数栈帧、函数调用原理" class="headerlink" title="2.4  函数栈帧、函数调用原理"></a>2.4  函数栈帧、函数调用原理</h4><p>帧的地址被存储到帧或者基址寄存器中<br>帧指针在栈中是一个定点的引用<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202104137.png"><br>子程序调用<br>执行前<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241114115410.png"><br>返回地址即EIP</p>
<ul>
<li><p>进入函数时会发生的：（接下来的都是该函数的栈帧）</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241115141301.png"></li>
<li>push ebp是old ebp，将old ebp存在栈里</li>
<li>move ebp,esp，即现在的ebp是old esp</li>
<li>再为新的函数分配临时空间<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241115141315.png"></li>
</ul>
</li>
<li><p>函数return()时会发生的</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241115141356.png"></li>
<li>move esp, ebp: 恢复esp栈顶指针为之前保存的old esp，同时回收栈上的局部变量</li>
<li>因为之前push ebp了，pop ebp即恢复栈底指针（pop这个值到EBP寄存器）</li>
<li>ret 从栈中取出返回地址（即返回地址弹给寄存器），并jump到该地址即返回之前的位置</li>
</ul>
</li>
</ul>
<p>函数栈帧(从高地址到低地址，从先在栈里的到后在)</p>
<ul>
<li>函数返回地址</li>
<li>栈帧状态值（old ebp）<ul>
<li>old esp可以通过堆栈平衡计算的到</li>
<li>用于在本帧被弹出后恢复上一个栈帧</li>
</ul>
</li>
<li>局部变量<ul>
<li>通过sub esp为函数局部变量开辟的内存空间</li>
</ul>
</li>
</ul>
<h6 id="函数调用的步骤"><a href="#函数调用的步骤" class="headerlink" title="函数调用的步骤"></a>函数调用的步骤</h6><ul>
<li>参数入栈（参数从右向左一次压入系统栈）</li>
<li>返回地址入栈（call指令）<ul>
<li>将下一跳指令地址入栈</li>
</ul>
</li>
<li>代码区跳转（修改EIP，call指令）<ul>
<li>处理器从当前代码区跳转到被调用函数的入口</li>
</ul>
</li>
<li>栈帧调整<ul>
<li>EBP入栈（保存当前栈帧状态值，以备后面恢复本栈帧）</li>
<li>更新EBP（move ebp,esp将当前栈帧切换到新栈帧</li>
<li>给新栈帧分配空间（sub esp）<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202114329.png"></li>
</ul>
</li>
</ul>
<h6 id="函数返回步骤"><a href="#函数返回步骤" class="headerlink" title="函数返回步骤"></a>函数返回步骤</h6><ul>
<li>保存返回值<ul>
<li>通常保存在寄存器EAX</li>
</ul>
</li>
<li>弹出当前栈帧，恢复上一个栈帧<ul>
<li>堆栈平衡的基础上，给ESP加上栈帧的大小，降低栈顶，回收当前栈帧的空间</li>
<li>pop ebp：old ebp弹出到EBP寄存器，恢复上一个栈帧</li>
<li>ret :函数返回地址弹给EIP<ul>
<li>并按返回地址jump回母函数</li>
</ul>
</li>
</ul>
</li>
<li>继续执行</li>
</ul>
<h6 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h6><p>这是因为在初始化、拷贝或移动数据时，C语言并不自动地支持内在的数组边界检查。虽然这提高了语言的执行效率，但其带来的影响及后果却是深远和严重的</p>
<ul>
<li>缓冲区溢出的预防<ul>
<li>静态保护<ul>
<li>不执行代码</li>
<li>编译时加入限制条件、返回地址保护、二进制改写技术、基于源码的代码审计</li>
</ul>
</li>
<li>动态保护<ul>
<li>执行代码测试是否有漏洞</li>
<li>保护主机上运行的程序防止来自外部的缓冲区溢出攻击</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202101303.png"></p>
<h2 id="字符串安全"><a href="#字符串安全" class="headerlink" title="字符串安全"></a>字符串安全</h2><p>使用C风格的字符串编程是很容易产生错误的<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206111224.png"></p>
<h3 id="3-1-常见字符串操作错误"><a href="#3-1-常见字符串操作错误" class="headerlink" title="3.1 常见字符串操作错误"></a>3.1 常见字符串操作错误</h3><ul>
<li>无界字符串复制<ul>
<li>从一个无界数据源复制数据到定长字符数组</li>
<li>strcpy()和strcat（）函数复制和连接字符也容易出现错误<ul>
<li>因为执行的是无界复制</li>
</ul>
</li>
<li>解决方法：<ul>
<li>动态分配内存</li>
<li>设置域宽<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202152223.png"></li>
</ul>
</li>
</ul>
</li>
<li>空结尾错误<ul>
<li>数字把空间占满了，没位置写\0了</li>
</ul>
</li>
<li>截断<ul>
<li>目标字符数组长度不足以容纳一个字符串的内容</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202161257.png"></li>
</ul>
</li>
<li>差一错误<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202161106.png"></li>
</ul>
</li>
<li>数组写入越界</li>
</ul>
<h3 id="字符串漏洞"><a href="#字符串漏洞" class="headerlink" title="字符串漏洞"></a>字符串漏洞</h3><h4 id="缓冲区溢出-1"><a href="#缓冲区溢出-1" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h4><p>当<strong>向</strong>为某特定数据结构分配的<strong>内存空间边界之外</strong>写入数据时，就会发生缓冲区溢出<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202163220.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202164038.png"></p>
<h4 id="栈粉碎"><a href="#栈粉碎" class="headerlink" title="栈粉碎"></a>栈粉碎</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202164201.png"></p>
<h4 id="代码注入"><a href="#代码注入" class="headerlink" title="代码注入"></a>代码注入</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202171627.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202171707.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202171536.png"></p>
<h4 id="弧注入"><a href="#弧注入" class="headerlink" title="弧注入"></a>弧注入</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202172404.png"><br>漏洞利用</p>
<ul>
<li>用存在的函数地址覆写返回地址</li>
<li>创建栈帧来链接函数调用</li>
<li>再现原始帧返回的程序，不进行检测并恢复执行</li>
</ul>
<p>弧注入优点</p>
<ul>
<li>攻击者可以将多个函数参数链在一起</li>
<li>代码是预先写入代码段的<ul>
<li>没有代码是被注入的</li>
<li>所以基于内存模式的保护不能阻止弧注入</li>
<li>不需要更大的缓冲区溢出</li>
</ul>
</li>
<li>原帧能被恢复，这样可以抵抗</li>
</ul>
<h3 id="缓解措施"><a href="#缓解措施" class="headerlink" title="缓解措施"></a>缓解措施</h3><ul>
<li>缓解措施包括<ul>
<li>预防</li>
<li>侦测，并安全地恢复，使漏洞利用的企图无法得逞</li>
</ul>
</li>
<li>防范策略<ul>
<li>静态</li>
<li>动态</li>
</ul>
</li>
</ul>
<h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202184020.png"></p>
<h5 id="输入验证"><a href="#输入验证" class="headerlink" title="输入验证"></a>输入验证</h5><p>确保输入数据的大小不超过其存储的最小缓冲区<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202212433.png"></p>
<h5 id="strlcpy-and-strlcat"><a href="#strlcpy-and-strlcat" class="headerlink" title="strlcpy() and strlcat()"></a><strong>strlcpy()</strong> and strlcat()</h5><p>更不容易出错的方式来复制和链接<br>两个函数都<strong>确保</strong>目标字符串对所有非零长度的缓冲区来说都是<strong>非空结尾</strong>的。?<br>    保证都是\0结尾</p>
<ul>
<li><p>strlcpy</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202213241.png"></li>
<li>&nbsp;从<strong>src</strong>复制空结尾的字符串到<strong>dst</strong> (直到<strong>size</strong> 大小的字符)。</li>
</ul>
</li>
<li><p>strlcat</p>
<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202213312.png"></li>
<li>把非空结尾的字符串<strong>src</strong> 连接到<strong>dst</strong>末尾 (不超过<strong>size</strong> 的字符都能够连接到dst末尾)</li>
</ul>
</li>
<li><p>该方法存在的问题：</p>
<ul>
<li>可能发生字符串截断<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202215426.png"></li>
<li>仍然可能会导致缓冲区溢出<ul>
<li>指定的缓冲区大小比实际的缓冲区长度长</li>
</ul>
</li>
</ul>
</li>
</ul>
<h5 id="ISO-x2F-IEC-“Security”-TR-24731"><a href="#ISO-x2F-IEC-“Security”-TR-24731" class="headerlink" title="ISO/IEC “Security” TR 24731"></a>ISO/IEC “Security” TR 24731</h5><p>ISO/IEC TR 24731 定义更少出错的C标准函数版本<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202215805.png"></p>
<ul>
<li>该方法优点<ul>
<li>不产生无结尾的字符串</li>
<li>不意外截断字符串</li>
<li>支持编译时检查</li>
<li>失败显现</li>
<li>统一的函数参数和返回类型模式</li>
</ul>
</li>
<li>以strcpy_s()为例<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202220221.png"></li>
<li>中间的参数&nbsp;rsize_t用来确定目标缓冲区（即s1）的最大长度</li>
<li>如果源字符串不能完全复制到目标缓冲区，或者目标缓冲区发生溢出，都返回失败</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202221552.png"></li>
</ul>
</li>
<li>该方法缺点<ul>
<li>仍能发生缓冲区溢出<ul>
<li>如标缓冲区的最大长度是不被正确指定</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="动态方法"><a href="#动态方法" class="headerlink" title="动态方法"></a>动态方法</h4><p>动态分配的缓冲区需要动态调整额外的内存<br>动态方法更好，而且不丢弃多余的数据。<br>主要缺点是,如果输入被限制，则可能</p>
<ul>
<li>耗尽机器内存</li>
<li>结果导致拒绝服务攻击</li>
</ul>
<h5 id="SafeStr"><a href="#SafeStr" class="headerlink" title="SafeStr"></a>SafeStr</h5><p>在需要精加字符串大小的操作中，重新分配内存并移动字符串内容<br>因此, 在使用这个库的时候，不会发生缓冲区溢出<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202225239.png"><br>例子：<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202225940.png"><br>有错误处理<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241202230022.png"></p>
<h5 id="管理字符串"><a href="#管理字符串" class="headerlink" title="管理字符串"></a>管理字符串</h5><ul>
<li>分配缓冲区</li>
<li>如果需要额外的内存，则重新调整内存大小</li>
<li>缺点<ul>
<li>无限制地消耗内存，可能导致拒绝服务攻击</li>
<li>性能开销</li>
</ul>
</li>
<li>举例：<ul>
<li>不透明数据类型<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206110801.png"></li>
<li>黑名单<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206110932.png"></li>
<li>白名单<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206111008.png"></li>
</ul>
</li>
</ul>
<h5 id="实验"><a href="#实验" class="headerlink" title="实验"></a>实验</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206112148.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206112154.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206112204.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206112651.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206113127.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206114120.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206114445.png"></p>
<h2 id="指针安全"><a href="#指针安全" class="headerlink" title="指针安全"></a>指针安全</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>指针安全是通过修改指针值来利用程序漏洞的方法的统称</p>
<ul>
<li>通过<strong>覆盖函数指针</strong>将程序的<strong>控制权转移</strong>到攻击者提供的外壳代码<ul>
<li>缓冲区覆写指针条件：<ul>
<li>缓冲区与目标指针必须分配在<strong>同一个段内</strong><ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206133922.png"></li>
</ul>
</li>
<li>&nbsp;<strong>缓冲区必须位于比目标指针更低的内存地址处</strong><ul>
<li>因为是从低地址往高地址写入的</li>
</ul>
</li>
<li>该缓冲区必须是界限不充分的，因此容易被缓冲区溢出利用</li>
</ul>
</li>
</ul>
</li>
<li>对象指针也可以被修改，从而执行任意代码<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206143435.png">即<br>缓冲区的定义在两个对象的前面，发生</li>
</ul>
<h5 id="覆盖函数指针举例"><a href="#覆盖函数指针举例" class="headerlink" title="覆盖函数指针举例"></a>覆盖函数指针举例</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206134914.png"></p>
<h5 id="覆盖对象指针举例"><a href="#覆盖对象指针举例" class="headerlink" title="覆盖对象指针举例"></a>覆盖对象指针举例</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206144724.png"></p>
<h3 id="修改指令指针"><a href="#修改指令指针" class="headerlink" title="修改指令指针"></a>修改指令指针</h3><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206150239.png"></p>
<p>举例，什么样的能够被利用：（什么情况下能恶意改变IC）<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206152635.png"></p>
<ul>
<li>静态调用（直接调用）是不能的<ul>
<li>因为静态调用是指令中地址被编码，再计算地址，再放入IC中</li>
<li>因此要改变IC，只能改变其指令</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206152703.png"></li>
</ul>
</li>
<li>通过函数指针调用函数可以<ul>
<li>因为通过函数指针的调用是<strong>间接引用</strong></li>
<li>IC的下一个值是存储在内存中的（指针地址处的内存的内容作为函数的地址）如果可以任意写的话，很容易被改变</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206152648.png"><ul>
<li>如这个例子中，可以改变478400h处的内容，即将函数地址改变</li>
</ul>
</li>
<li><strong>间接的函数引用</strong>与<strong>无法在编译期间决定的</strong>函数调用可以被利用，从而使程序的控制权转移到任意代码</li>
</ul>
</li>
</ul>
<h4 id="修改指令指针的目标"><a href="#修改指令指针的目标" class="headerlink" title="修改指令指针的目标"></a>修改指令指针的目标</h4><h5 id="全局偏移表"><a href="#全局偏移表" class="headerlink" title="全局偏移表"></a>全局偏移表</h5><p>在<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206160958.png">中的文件格式ELF，默认二进制格式</p>
<h6 id="GOT特点"><a href="#GOT特点" class="headerlink" title="GOT特点"></a>GOT特点</h6><p>其中ELF二进制文件的进程空间中有GOT，Global Offset Table，要使得动态链接的进程能够工作，其必不可少<br>GOT存放绝对地址<br><strong>GOT工作流程</strong></p>
<ul>
<li>GOT入口项包含运行时连接器RTL（runtime linker）的地址</li>
<li>程序首次调用一个函数，程序的控制权被转移到RTL</li>
<li>RTL解析出函数地址，RTL将地址写入GOT</li>
<li>接下来就可以通过GOT中的入口项直接调用函数<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206161728.png"></li>
</ul>
<p><strong>GOT特点</strong></p>
<ul>
<li>ELF可执行文件中的GOT入口项的地址是固定的<ul>
<li>对任何可执行进程映像而言GOT入口项都位于相同的地址<br>所以可以利用objdump命令查看某一个函数的GOT入口项位置</li>
</ul>
</li>
<li>记录的是偏移量<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206164159.png"></li>
</ul>
</li>
</ul>
<h6 id="如何利用GOT"><a href="#如何利用GOT" class="headerlink" title="如何利用GOT"></a>如何利用GOT</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206164249.png"></p>
<h5 id="dtors区"><a href="#dtors区" class="headerlink" title="dtors区"></a>dtors区</h5><h6 id="什么是dtors区"><a href="#什么是dtors区" class="headerlink" title="什么是dtors区"></a>什么是dtors区</h6><p>.dtors</p>
<ul>
<li>仅存在于用GCC编译和链接的程序中</li>
<li>该区总是存在并且会映射到内存中，默认属性为可写，<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206165902.png"></li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206165327.png"></li>
<li>析构函数存储于ELF的.dtors区</li>
<li>析构函数在main执行完后调用，而构造函数在main之前调用<ul>
<li>因而构造函数没法被漏洞程序利用</li>
<li>举例<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206165811.png"></li>
</ul>
</li>
</ul>
<h6 id="如何利用"><a href="#如何利用" class="headerlink" title="如何利用"></a>如何利用</h6><p>优点：<br>对于攻击者而言，覆写.dtors区的好处在于： 该区总是存在并且会映射到内存中，并且是可写的</p>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206170143.png"><br>缺点：<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206170201.png"></p>
<h5 id="虚函数-1"><a href="#虚函数-1" class="headerlink" title="虚函数***"></a>虚函数***</h5><h6 id="什么是虚函数"><a href="#什么是虚函数" class="headerlink" title="什么是虚函数"></a>什么是虚函数</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206170707.png"></p>
<ul>
<li><p>运行时解析即函数调用的动态绑定</p>
<ul>
<li>虚函数只有通过对象指针的引用才能显示出其动态调用的特性</li>
</ul>
</li>
<li><p>虚函数实现</p>
<ul>
<li>每一个对象头部有虚指针VPTR，Virtual Pointer</li>
<li>虚指针指向虚函数表VTBL，Virtual Function Table</li>
<li>虚函数表中有函数指针，指向每个函数实现<ul>
<li>VTBL是一个函数指针数组</li>
</ul>
</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206171042.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207143302.png"></li>
</ul>
</li>
</ul>
<h6 id="如何利用虚函数"><a href="#如何利用虚函数" class="headerlink" title="如何利用虚函数"></a>如何利用虚函数</h6><ol>
<li>覆写虚指针，使指向其他虚函数表</li>
<li>覆写虚函数表中的函数指针<br>攻击者可以通过任意内存写或者利用缓冲区溢出直接写入对象实现这一操作</li>
</ol>
<h6 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207143340.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207143432.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207144638.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207152249.png"></p>
<h6 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h6><p>由于虚表指针在对象头部，位于成员变量之前，而对象中，地址是从低地址向高地址增长的（与栈相反），所以虚表指针在低地址处，成员变量在高地址处</p>
<p>而溢出又只能是从低地址往高地址写，因此需要目标在可写处的高地址才行<br>所以没法使用栈溢出来修改虚表指针<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207154202.png"><br>但是可以使用溢出方法来覆盖邻接对象的虚表<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207154247.png"></p>
<h5 id="atexit-on-exit"><a href="#atexit-on-exit" class="headerlink" title="atexit() on_exit"></a>atexit() on_exit</h5><p>atexit，被称为登记函数<br>在程序正常结束后调用<br>⼀个进程可以登记若⼲个个函数，这些函数由exit<strong>⾃动调⽤</strong>，这些函数被称为<strong>终⽌处理函数</strong>， atexit函数可以登记这些函数。 exit调⽤终⽌处理函数的顺序和atexit登记的顺序相反<br>登记的这些在_exit_funcs里···<br>atexit()注册的这些函数会显示在__exit_funcs 位置处的内存<br>每个函数保存在四个双字构成的结构中，其中最后一个双字是函数的实际地址</p>
<h6 id="利用例子"><a href="#利用例子" class="headerlink" title="利用例子"></a>利用例子</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206174323.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206225851.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241206230141.png"></p>
<h5 id="longjmp"><a href="#longjmp" class="headerlink" title="longjmp()"></a>longjmp()</h5><h6 id="什么是longjmp"><a href="#什么是longjmp" class="headerlink" title="什么是longjmp"></a>什么是longjmp</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207102823.png">即调用longjmp的时候，会跳到setjmp的调用处，并给setjmp一个返回值，即val<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207103022.png"></p>
<p>深究是如何跳到setjmp的：setjmp将局部环境保存在jmp_buf中，longjmp可以根据其恢复环境</p>
<p>则引出攻击点：如何让longjmp跳到错误的地方</p>
<h6 id="如何利用-1"><a href="#如何利用-1" class="headerlink" title="如何利用"></a>如何利用</h6><ul>
<li>jmp_buf的实现：<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207103543.png"></li>
<li>longjmp具体如何恢复环境<ul>
<li>先将返回值存在eax</li>
<li>再恢复ebp与esp</li>
<li>再恢复PC，即将程序控制权转移</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207104039.png"></li>
</ul>
</li>
<li>因此可以通过缓冲区溢出，覆写 JB_PC字段，则可以使程序跳转到shellcode处执行</li>
</ul>
<h5 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理***"></a>异常处理***</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207132003.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207132013.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207132103.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207132233.png"><br>即SEH链，每个是EXECPTION_REGISTRATION结构，<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207132319.png"><br>其中handler指向异常处理函数<br>而prev指向下一个EXECPTION_REGISTRATION结构</p>
<p>而异常处理程序地址在栈的高地址处，局部变量在栈的较之低地址处，即如果<strong>栈变量发生缓冲区溢出</strong>，那么<strong>异常处理程序地址就可以被覆写</strong><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207133401.png"></p>
<h6 id="如何利用-2"><a href="#如何利用-2" class="headerlink" title="如何利用"></a>如何利用</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207133422.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207133532.png"></p>
<h3 id="内存任意写技术"><a href="#内存任意写技术" class="headerlink" title="内存任意写技术"></a>内存任意写技术</h3><h3 id="缓解措施-1"><a href="#缓解措施-1" class="headerlink" title="缓解措施"></a>缓解措施</h3><p><strong>防止指针诡计的最佳方式就是消除<strong><strong>”</strong></strong>允许内存被不正确地覆写”****的漏洞</strong></p>
<ul>
<li>消除“允许内存被不正确地覆写”漏洞<ul>
<li>覆写对象指针</li>
<li>常见的动态内存管理错误</li>
<li>字符串格式化漏洞</li>
</ul>
</li>
<li>减少目标暴露<ul>
<li>写或者执行，只允许一个<ul>
<li>但不能防止atexit这样的</li>
</ul>
</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207140311.png"></li>
</ul>
</li>
<li>栈探测仪<ul>
<li>能保护<ul>
<li>仅对那些预通过溢出栈缓冲区来覆写栈指针或者其它受保护区域的漏洞利用有效。</li>
</ul>
</li>
<li>不能保护<ul>
<li>栈探测仪并不能防止<strong>对变量、对象指针或者函数指针</strong>进行修改的漏洞利用。</li>
<li>栈探测仪<strong>不能阻止包括栈段在内的任何位置发生缓冲区溢出</strong>。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>栈溢出攻击被用于覆写返回地址</strong>一样，<strong>缓冲区溢出可被用于覆写对象指针或函数指针</strong>。覆写函数指针或对象指针的能力取决于缓冲区溢出发生的地址和目标指针之间距离的远近，不过一般而言，同一个内存段内都存在这样的</p>
<p>Windows内存安全机制：GS编译、DEP、Heap cookie、Safe Unlink、ASLR？</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207142719.png"></p>
<h2 id="动态内存管理"><a href="#动态内存管理" class="headerlink" title="动态内存管理"></a>动态内存管理</h2><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207155907.png"></p>
<h3 id="动态内存管理函数"><a href="#动态内存管理函数" class="headerlink" title="动态内存管理函数"></a>动态内存管理函数</h3><h4 id="C标准定义的内存分配函数（？alloc和free）"><a href="#C标准定义的内存分配函数（？alloc和free）" class="headerlink" title="C标准定义的内存分配函数（？alloc和free）"></a>C标准定义的内存分配函数（？alloc和free）</h4><h5 id="calloc"><a href="#calloc" class="headerlink" title="calloc()"></a>calloc()</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207161405.png"><br>新分配的内容有初始化，初始化为0</p>
<h5 id="malloc"><a href="#malloc" class="headerlink" title="malloc()"></a>malloc()</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207160507.png"></p>
<p>新分配的内存未做初始化</p>
<h5 id="realloc"><a href="#realloc" class="headerlink" title="realloc()"></a>realloc()</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207160802.png"><br>即旧的不变，扩大的内存（即新分配的内存）未初始化</p>
<ul>
<li>若p为空指针，则等价为malloc<ul>
<li>若p不是空指针，则p必须是alloc返回的指向内存的指针</li>
</ul>
</li>
<li>若size=0，则等价于调用free(p)</li>
</ul>
<h5 id="free-释放内存"><a href="#free-释放内存" class="headerlink" title="free()释放内存"></a>free()释放内存</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207160551.png"><br>p必须是alloc的返回指针<br>不能释放两遍<br>p为空指针则不执行任何操作</p>
<h4 id="Cpp标准的（new和delete）"><a href="#Cpp标准的（new和delete）" class="headerlink" title="Cpp标准的（new和delete）"></a>Cpp标准的（new和delete）</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207161551.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207161557.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207161618.png"></p>
<ul>
<li>new关键字与malloc函数区别<ul>
<li>内存分配单位不同<ul>
<li>new以具体类型为单位进行内存分配</li>
<li>malloc以字节为单位进行内存分配</li>
</ul>
</li>
<li>是否初始化不同<ul>
<li>new在申请单个类型变量的时候可以进行初始化</li>
<li>而malloc没有对内存初始化</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="内存分配算法"><a href="#内存分配算法" class="headerlink" title="内存分配算法"></a>内存分配算法</h3><ul>
<li>连续匹配<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183322.png"></li>
</ul>
</li>
<li>最先匹配<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183337.png"></li>
</ul>
</li>
<li>最佳匹配<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183356.png"></li>
</ul>
</li>
<li>最优匹配<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183429.png"></li>
</ul>
</li>
<li>最差匹配<ul>
<li>挑最大的空闲块</li>
</ul>
</li>
<li>伙伴系统方法<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183911.png"></li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207183925.png"></li>
</ul>
</li>
<li>隔离<ul>
<li>保持单独的大小一致的块的列表</li>
</ul>
</li>
</ul>
<h3 id="常见内存管理错误"><a href="#常见内存管理错误" class="headerlink" title="常见内存管理错误"></a>常见内存管理错误</h3><h4 id="初始化错误"><a href="#初始化错误" class="headerlink" title="初始化错误"></a>初始化错误</h4><ul>
<li>程序员<strong>假设</strong>malloc()把分配的内存的所有位初始化为零<ul>
<li>实际上malloc不会进行初始化</li>
</ul>
</li>
<li></li>
</ul>
<h4 id="未检查返回值"><a href="#未检查返回值" class="headerlink" title="未检查返回值"></a>未检查返回值</h4><p>内存是有限的资源，它可能会被耗尽<br>内存分配可能失败<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207185645.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207185727.png"></p>
<ul>
<li><p>malloc分配的</p>
<ul>
<li>若分配失败，会返回NULL指针</li>
<li>可以这样检查<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207185811.png"></li>
</ul>
</li>
<li><p>new分配的</p>
<ul>
<li>若分配失败，会抛出异常<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207190017.png"></li>
<li>检查：<ul>
<li>不能直接用if，因为有抛出异常，if的判断永远是真值，例子：<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207190150.png"></li>
<li>可以使用new(nothrow)检查，这样如果分配失败会返回NULL指针<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207190308.png"></li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="引用已释放的内存"><a href="#引用已释放的内存" class="headerlink" title="引用已释放的内存"></a>引用已释放的内存</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207194114.png"></p>
<h4 id="4-多次释放内存"><a href="#4-多次释放内存" class="headerlink" title="4. 多次释放内存"></a>4. 多次释放内存</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241207194435.png"></p>
<h4 id="5-不正确配对内存管理函数"><a href="#5-不正确配对内存管理函数" class="headerlink" title="5. 不正确配对内存管理函数"></a>5. 不正确配对内存管理函数</h4><p>应该正确配对<br>new 配对 delete<br>malloc 配对 free<br>不恰当的配对是不可移植的</p>
<h4 id="6-未能区分标量和数组"><a href="#6-未能区分标量和数组" class="headerlink" title="6. 未能区分标量和数组"></a>6. 未能区分标量和数组</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241213192938.png"><br>如使用了new[] 分配就要用对应的delete[] 释放<br>否则可能导致内存泄漏，或者未定义的行为导致崩溃</p>
<h4 id="7-分配函数的不当使用"><a href="#7-分配函数的不当使用" class="headerlink" title="7. 分配函数的不当使用"></a>7. 分配函数的不当使用</h4><ul>
<li>malloc(0)<ul>
<li>C运行时库能返回空指针或者伪地址</li>
<li>空指针即没分配内存，伪地址即给分配了指针，但该指针是无效的，分配的内存不能用于存储数据</li>
<li>最安全和便捷的解决方案是确保没有零长度分配</li>
</ul>
</li>
<li>alloca()<ul>
<li>定义<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241213194748.png"></li>
</ul>
</li>
<li>功能<ul>
<li>在调用者的栈中分配内存。<ul>
<li>即使用这个函数分配的内存是在栈空间的</li>
<li>分配的内存的生命周期与函数调用的生命周期是相同的</li>
</ul>
</li>
<li>在 “调用alloca()的函数“ 返回时， alloca()分配的内存会自动释放<ul>
<li>因为是在栈中的</li>
<li>所以无需手动调用free()释放</li>
</ul>
</li>
</ul>
</li>
<li>潜在的问题<ul>
<li>通常实现为内联函数，直接将代码插入调用点，通过栈指针调整来分配内存，且内存分配过程非常简单，内联化能够更好地适应这种低级别、快速的操作<ul>
<li>不会返回空指针<ul>
<li>即使分配错误了，只是会导致栈溢出或程序崩溃，程序员无法通过简单的返回值检查来判断是否成功分配了内存</li>
</ul>
</li>
</ul>
</li>
<li>分配空间时候可能导致栈溢出（超出栈边界）<ul>
<li>栈空间的大小通常是有限制的，这个是在栈空间分配的</li>
</ul>
</li>
<li>程序员误以为该函数要配上free（）释放内存<ul>
<li>导致双重释放</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="dlmalloc"><a href="#dlmalloc" class="headerlink" title="dlmalloc"></a>dlmalloc</h3><h4 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h4><h5 id="块结构"><a href="#块结构" class="headerlink" title="块结构"></a>块结构</h5><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241213201833.png"></p>
<ul>
<li>块开始的4字节：<ul>
<li>若该块前一个块为空闲块，则该块开始的四字节包含前一块的大小，prev,previous</li>
<li>若该块前一个块为已分配块，则包含前一内存块用户数据的最后四个字节</li>
</ul>
</li>
<li>PREV_INUSE<ul>
<li>PREV_INUSE位被存储于块大小的低位中</li>
<li>标志位，若当前内存块<strong>前一块已分配，则为1</strong></li>
</ul>
</li>
<li>这里的fd to next是前向指针，指向下一个内存块，bd to prev是后向指针，指向的是前一个内存块</li>
</ul>
<h5 id="空闲块组织方式"><a href="#空闲块组织方式" class="headerlink" title="空闲块组织方式"></a>空闲块组织方式</h5><ul>
<li>空闲块被组织成筐<ul>
<li>每个“筐”里存放的是<strong>差不多大小</strong>的空闲块</li>
<li>每个筐都有一个“头索引” head element，指向每个“筐”的位置。它帮助 dlmalloc 快速找到合适的内存块，避免浪费时间遍历所有内存块。</li>
<li>缓存框<ul>
<li>用于存放最近刚刚释放的空闲块。</li>
<li>利用局部性原理，最近释放的块很可能会很快被重复使用。所以，dlmalloc 会把这些块放在缓存筐里，方便快速分配。</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241213210405.png"></p>
<h4 id="解链操作unlink"><a href="#解链操作unlink" class="headerlink" title="解链操作unlink"></a>解链操作unlink</h4><h6 id="基础知识-1"><a href="#基础知识-1" class="headerlink" title="基础知识"></a>基础知识</h6><p><strong>解链（unlink）</strong> 就是指从这个链表中移除某个内存块，以便合并或重新分配。<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241213211249.png"><br>使用场合</p>
<ul>
<li>free<ul>
<li>释放内存块时，可能需要检查并合并空闲块</li>
<li>如果释放的<strong>内存块前后相邻的块也是空闲</strong>的，那么释放操作会将这些相邻的空闲块<strong>合并</strong><ul>
<li>这个时候就需要解链技术，把那个空闲块解链，合并后再插回去</li>
</ul>
</li>
</ul>
</li>
<li>malloc<ul>
<li>要从空闲链表中分配一个内存块时，<strong>dlmalloc</strong> 会使用解链操作将该空闲块从链表中取出。</li>
</ul>
</li>
</ul>
<h6 id="如何利用-3"><a href="#如何利用-3" class="headerlink" title="如何利用"></a>如何利用</h6><p>要让dlmalloc误以为第二块内存是未分配的，free()才会unlink()宏来合并自己和下一个内存块（目的是合并first,second）？</p>
<ul>
<li><p>可以让free()找错第三块的地址：</p>
<ul>
<li>将第二块内存的起始位置加上其大小，得到第三块的地址</li>
<li>因此可以通过覆盖第二块内存中<ul>
<li>上一块内存大小，四字节<ul>
<li>例如，第二块内存大小被修改为-4</li>
<li>因此会去那找第三块，会使dlmalloc所找到的PREV_INUSE标志位为空，所以以为second为未分配的，导致free（first）调用unlink宏来合并first和second</li>
</ul>
</li>
<li>size（自己这块）四字节</li>
<li>前向、后向指针</li>
</ul>
</li>
</ul>
</li>
<li><p>找错第三块的目的是让free（first）以为second未分配，从而使free（）调用unlink宏，从而实现<strong>任意地址处写入4字节数据</strong></p>
<ul>
<li>调用unlink宏的目的是要实现任意写入</li>
<li>即，因为覆写了第二块的fd和bk指针，可以实现向这俩的地址写入<ul>
<li>unlink()宏将攻击者提供的4个字节的数据写到同样是由攻击者指定的4个字节的地址处</li>
</ul>
</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217151846.png">攻击者可能会提供栈中指令指针的地址，将其覆写为恶意代码的地址</li>
</ul>
</li>
<li><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217152303.png"></p>
</li>
<li><p>该利用方式困难之处在于精确确定第一块内存的大小</p>
<ul>
<li>攻击者可以从dlmalloc中复制request2size(req, nb)宏的代码到其利用代码中<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217154041.png"></li>
</ul>
</li>
</ul>
<h4 id="Frontlink技术"><a href="#Frontlink技术" class="headerlink" title="Frontlink技术"></a>Frontlink技术</h4><p>当一块内存被释放时，它必须被正确地链接进双链表中，在dlmalloc的某些版本中，此项操作是由frontlink ()代码段完成的</p>
<h6 id="基础知识-2"><a href="#基础知识-2" class="headerlink" title="基础知识"></a>基础知识</h6><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217161416.png"><br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217161408.png"></p>
<h6 id="如何利用-4"><a href="#如何利用-4" class="headerlink" title="如何利用"></a>如何利用</h6><ul>
<li><p>shellcode的最后4个字节就是跳转到shellcode其他部分的跳转指令</p>
<ul>
<li>这4个字节要是first块的最后4个字节，在second开头</li>
</ul>
</li>
<li><p>为确保该条件能满足，被攻击的内存块的字节长度必须是<strong>8的整数倍-4</strong>‘？</p>
</li>
<li><p>通过对fourth内存块溢出到fifth块，并覆写其中的前向（fd to next）指针<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217163735.png"></p>
<ul>
<li>使其指向一个假内存块</li>
<li>这个假内存块的后向（bk to prev假内存块地址addr+12）指针包含一个函数指针地址<ul>
<li>一个合适的函数指针：存储于程序.dtors区中的第一个析构函数的地址<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217165536.png">以通过检查可执行映像而获得这个地址</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217181549.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217181607.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217181623.png">所以前面先利用了first块的无界复制，导致second块被改变，即可以实现任意的信息覆写进函数指针（此处用second来覆盖.dtors地址 ，而second为first覆盖，指向的是first中的shellcode）<br>程序正常结束的时候，会去调用析构函数，而被shellcode覆盖了，即程序结束后会调用shellcode</p>
<h4 id="双重释放"><a href="#双重释放" class="headerlink" title="双重释放"></a>双重释放</h4><p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217182626.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217182730.png"><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217182744.png"></p>
<p><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241219205103.png">二次释放first内存后，再分配，并向first里写入strcpy的GOT地址和seecode地址<br>再次malloc的时候，还是相同的first，而unlink宏会将shellcoded的地址复制到全局偏移表中的strcpy的地址处<br>当程序调用strcpy时，即在调用shellcode</p>
<p>shellcode需要填充前面的12字节，因为这部分被unlink宏所覆写<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241219205546.png"></p>
<p>写入到已释放内存也是安全缺陷<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241219212203.png"></p>
<h3 id="RTL-Heap-x2F-堆"><a href="#RTL-Heap-x2F-堆" class="headerlink" title="RTL Heap/堆"></a>RTL Heap/堆</h3><p>RTL，runtime library使用了<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241225150117.png"></p>
<ol>
<li>虚拟内存API<ol>
<li>32位地址</li>
<li>4KB页</li>
</ol>
</li>
<li>堆内存API<ol>
<li>每一个进程都有一个默认堆</li>
<li>允许用户建立多个动态堆</li>
</ol>
</li>
<li>局部内存和全局内存API</li>
<li>CRT内存函数</li>
<li>内存映射API<ol>
<li>内存映射文件允许一个应用程序将其虚拟地址空间之间映射到磁盘上的一个文件</li>
</ol>
</li>
</ol>
<h5 id="使用的数据结构"><a href="#使用的数据结构" class="headerlink" title="使用的数据结构"></a>使用的数据结构</h5><h6 id="进程环境块PEB"><a href="#进程环境块PEB" class="headerlink" title="进程环境块PEB"></a>进程环境块PEB</h6><p>位置：<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241225155509.png"><br>PEB给出堆数据结构的信息<br><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241225155554.png"></p>
<h6 id="空闲链表"><a href="#空闲链表" class="headerlink" title="空闲链表"></a>空闲链表</h6><p>有128个双向链表的数组，链表被RTL堆用来跟踪空闲内存块</p>
<ul>
<li>Freelist[]是个LIST_ENTRY结构的数组<ul>
<li>每－个LIST_ENTRY表示一个双链表的头部，由一个前向链接（ flink ）和一个后向链接（ blink ）组成</li>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241225160752.png"></li>
<li>每个链表中从小到大开始排，</li>
<li>创建一个新堆时，空闲链表被初始化为空，即前向和后向链接都指向链表头</li>
</ul>
</li>
<li><h2 id="后备缓存链表"><a href="#后备缓存链表" class="headerlink" title="后备缓存链表"></a>后备缓存链表</h2></li>
</ul>
<h2 id="整数安全"><a href="#整数安全" class="headerlink" title="整数安全"></a>整数安全</h2><h3 id="整数数据类型"><a href="#整数数据类型" class="headerlink" title="整数数据类型"></a>整数数据类型</h3><ul>
<li>原码表示方法<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217195747.png"></li>
<li>反码表示方法<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217195819.png"></li>
<li>补码表示方法<img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217195914.png"></li>
<li>带符号和无符号<ul>
<li><img lazyload="" src="/images/loading.svg" data-src="/../images/Pasted%20image%2020241217200044.png"></li>
</ul>
</li>
</ul>
<h3 id="整数的转换"><a href="#整数的转换" class="headerlink" title="整数的转换"></a>整数的转换</h3><h3 id="整数的操作"><a href="#整数的操作" class="headerlink" title="整数的操作"></a>整数的操作</h3><h3 id="整数的漏洞"><a href="#整数的漏洞" class="headerlink" title="整数的漏洞"></a>整数的漏洞</h3>]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
</search>
